<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tryhackme 密码学基础</title>
      <link href="/2025/02/10/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/02/10/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>话说回来 来到了密码学专区了</p><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/title1.png" alt="title"></p><p>密码学在生活中无处不在</p><h1 id="cyptography-basics"><a href="#cyptography-basics" class="headerlink" title="cyptography basics"></a>cyptography basics</h1><p>来看看密码学的一些术语</p><ul><li><p>明文(Plaintext)是加密前的原始可读消息或数据。它可以是文档、图像、多媒体文件或任何其他二进制数据。</p></li><li><p>密文(Ciphertext)是加密后的消息的混乱且不可读的版本。理想情况下，我们无法获得有关原始明文的任何信息，除了其大致大小。</p></li><li><p>密码(Cipher)是一种将明文转换为密文并再转换回明文的算法或方法。密码通常由数学家开发。</p></li><li><p>密钥(Key )是密码用于加密或解密数据的一串位。一般来说，使用的密码是公开的；但是，除非密钥是非对称加密中的公钥，否则它必须保密。我们将在后面的任务中讨论非对称加密。</p></li><li><p>加密(Encryption)是使用密码和密钥将明文转换为密文的过程。与密钥不同，密码的选择是公开的。</p></li><li><p>解密(Decryption)是加密的逆过程，使用密码和密钥将密文重新转换为明文。尽管密码是公开的，但在不知道密钥的情况下恢复明文应该是不可能的（不可行）</p></li></ul><p>来看看加密和解密的图解</p><p>此为加密<br><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/en.png" alt="task"></p><p>此为解密<br><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/de.png" alt="task"></p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p>看两个问题</p><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/task3.png" alt="task3"></p><p>第一个 毋庸置疑 密文(ciphertext)</p><p>第二个 转化为明文就是解密</p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p>凯撒密码 顾名思义就是凯撒搞出来的加密方法 将每个字母移动一定数字来加密消息</p><p>分为明文 偏移量 密码<br>举例：</p><ul><li>假设明文为ikun</li><li>偏移量为3(像右3个字母)</li><li>密码为lnxq</li></ul><p>假设知道密文和偏移量 也能倒推出明文</p><p>来试试看吧</p><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/task4.png" alt="task4"></p><p>可以试试这个<a href="https://www.dcode.fr/caesar-cipher">网站</a> 相信很多师傅都有这种密码破解的 一下子梭出来了</p><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/depy.png" alt="task"></p><p>第一个就是答案</p><h2 id="加密类型"><a href="#加密类型" class="headerlink" title="加密类型"></a>加密类型</h2><p>分为对称加密和非对称加密</p><p>对称加密，使用相同的密钥来加密和解密数据，</p><p>特点：</p><ul><li>密钥相同：发送和接收双方共享一个密钥，因此加密和解密过程都依赖于相同的密钥。</li><li>速度较快：对称加密算法通常计算速度较快，适用于加密大量数据。</li><li>密钥管理问题：因为密钥是共享的，密钥的分发和管理需要非常小心，密钥一旦泄漏，所有加密的数据都可能被破解</li></ul><p>常用的对称加密DES 3DES AES RC4</p><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/duicheng.png" alt="task"></p><p>非对称加密<br>又称公钥加密<br>非对称加密使用一对密钥：公钥（Public Key）和 私钥（Private Key）。公钥用于加密，私钥用于解密。加密和解密使用不同的密钥。</p><ul><li>加密：发送方使用接收方的公钥对数据进行加密。</li><li>解密：接收方使用自己的私钥对数据进行解密。</li></ul><p>特点：</p><ul><li>密钥不同：加密和解密使用不同的密钥，其中公钥可以公开，而私钥必须保密。</li><li>安全性高：即使公钥被泄露，也无法通过公钥解密数据，只有私钥能解密。</li><li>速度较慢：由于非对称加密算法的计算复杂度较高，因此相对于对称加密，非对称加密速度较慢，通常用于加密少量数据，如传输密钥。</li></ul><p>常见的非对称加密有RSA DSA Diffie-Hellman ecc</p><h2 id="基础计算"><a href="#基础计算" class="headerlink" title="基础计算"></a>基础计算</h2><p>异或计算</p><p>XOR是“异或”的缩写，是二进制算术中的逻辑运算，在各种计算和加密应用中起着至关重要的作用。在二进制中，XOR比较两个位，如果位不同则返回 1，如果位相同则返回0，</p><p>我们要对二进制数 1010 和 1100 进行异或运算。在这种情况下，我们逐位执行操作：1 ⊕ 1 &#x3D; 0、0 ⊕ 1 &#x3D; 1、1 ⊕ 0 &#x3D; 1 和 0 ⊕ 0 &#x3D; 0，结果为 0110。</p><p>模运算 </p><p>步骤：</p><ul><li>除法运算：将 a 除以 b。</li><li>求余数：计算除法后的余数。</li></ul><p>例子 2：15 % 4<br>除法运算：15 ÷ 4 &#x3D; 3，商是 3。<br>求余数：15 - (4 × 3) &#x3D; 15 - 12 &#x3D; 3，所以 15 % 4 &#x3D; 3。</p><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/task6.png" alt="task6"></p><p>异或计算就是每个相对应的位数 分别计算 相同为0 不同为1</p><p>1⊕1&#x3D;0<br>0⊕0&#x3D;0<br>0⊕1&#x3D;1<br>1⊕0&#x3D;1</p><p>第一问答案就是0011</p><p>第二问可以到<a href="https://www.wolframalpha.com/">这里</a>计算</p><p>第三问 因为60可以与12整除 余数为0</p><h1 id="Public-Key-Cryptography-Basics"><a href="#Public-Key-Cryptography-Basics" class="headerlink" title="Public Key Cryptography Basics"></a>Public Key Cryptography Basics</h1><p><img src="/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/public%20key.png" alt="task"></p><p>网络通信中要注意</p><ul><li>身份验证：确保与正确的人进行交流，而不是与其他人假装的交流。</li><li>真实性：可以验证信息是否来自所声称的来源。</li><li>完整性：必须确保没有人更改您交换的数据。</li><li>保密性：想防止未经授权的一方窃听您的谈话。</li></ul><p>这个章节主要是讲公钥加密 也就是非对称加密</p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p>非对称加密其实就有点像你放了一个信到一个上锁的信箱里面。每个人都可以放信进去 但是只有你才能打开信箱的锁拿出信来看内容</p><p>公钥就是信箱的投递口<br>私钥就是取信的钥匙</p><h2 id="task3-1"><a href="#task3-1" class="headerlink" title="task3"></a>task3</h2><p>来认识认识rsa</p><p>rsa的计算过程</p><ol><li>Bob 选择了两个素数：p  &#x3D; 157和q  &#x3D; 199。他计算出n  &#x3D;  p  ×  q  &#x3D; 31243。</li><li>假设ϕ ( n ) &#x3D;  n  −  p  −  q  + 1 &#x3D; 31243 − 157 − 199 + 1 &#x3D; 30888，Bob 选择e  &#x3D; 163 ，使得e与ϕ ( n )互质；此外，他选择d  &#x3D; 379，其中e  ×  d  &#x3D; 1 mod ϕ ( n )，即e  ×  d  &#x3D; 163 × 379 &#x3D; 61777且61777 mod 30888 &#x3D; 1。公钥为( n , e )，即(31243,163)，私钥为 $(n,d) ，即(31243,379)。</li><li>假设他们想要加密的值是x  &#x3D; 13，那么 Alice 将计算并发送y  &#x3D;  x e mod n  &#x3D; 13 163 mod 31243 &#x3D; 16341。</li><li>Bob 将通过计算x  &#x3D;  y d mod n  &#x3D; 16341 379 mod 31243 &#x3D; 13来解密收到的值。这样，Bob 就恢复了 Alice 发送的值。</li></ol><p>看看问题</p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/task3.png" alt="task3"></p><p>也是醉了 出了个寂寞</p><p>第一问就是4391*6659&#x3D;29239669</p><p>第二问就是29239669-4391-6659+1&#x3D;29228620</p><p>分别是第一步和第二步的开头</p><h2 id="task4-1"><a href="#task4-1" class="headerlink" title="task4"></a>task4</h2><p>Diffie-Hellman Key Exchange 简称就叫dh协议 密钥交换</p><p>密钥交换旨在在双方之间建立共享秘密。这是一种允许双方在非安全通信信道上建立共享秘密的方法，无需预先存在共享秘密，观察者也无法获取此密钥。因此，此共享密钥可用于后续通信中的对称加密。</p><p>研究一下具体的过程。</p><p>步骤 1: 公共材料<br>Alice 和 Bob 确定一个公共的素数p 和一个公共的生成器g，这两者对双方都是公开的。假设我们选择：<br>p &#x3D; 29（一个素数）<br>g &#x3D; 3（生成器）<br>这些值是公开的，任何人都可以知道它们。</p><p>步骤 2: Alice 和 Bob 各自选择私钥<br>Alice 选择一个私钥 a，并且不能告诉别人。假设 Alice 选择了私钥 a &#x3D; 13。<br>Bob 选择一个私钥 b，并且也不会告诉别人。假设 Bob 选择了私钥 b &#x3D; 15。<br>这些私钥是保密的，只由 Alice 和 Bob 知道。</p><p>步骤 3: 计算公钥<br>根据 Diffie-Hellman 的规则，每个人使用自己的私钥来计算公钥：</p><p>Alice 的公钥：A &#x3D; g^a mod p<br>A &#x3D; 3^13 mod 29<br>计算 3^13 mod 29：<br>3^13 &#x3D; 1594323，<br>然后 A mod p<br>1594323 mod 29 &#x3D; 19<br>所以 Alice 的公钥是 A &#x3D; 19。</p><p>Bob 的公钥：B &#x3D; g^b mod p<br>B &#x3D; 3^15 mod 29<br>计算 3^15 mod 29：<br>3^15 &#x3D; 14348907，<br>然后 B mod p<br> 14348907 mod 29 &#x3D; 26<br>所以 Bob 的公钥是 B &#x3D; 26。</p><p>步骤 4: Alice 和 Bob 交换公钥<br>Alice 发送自己的公钥 A &#x3D; 19 给 Bob。<br>Bob 发送自己的公钥 B &#x3D; 26 给 Alice。<br>这时，Alice 和 Bob 都拥有对方的公钥。</p><p>步骤 5: 计算共享密钥<br>Alice 和 Bob 使用自己私有的密钥 的公钥来计算共享密钥：</p><p>Alice 的计算：<br>Alice 收到 Bob 的公钥 B &#x3D; 26，然    算 B^a mod p：<br>B^a mod p &#x3D; 26^13 mod 29<br>计算 26^13 mod 29：<br>26^13 &#x3D; 10460353203，然后 104603    mod 29 &#x3D; 10<br>所以 Alice 得到的共享密钥是 10。    </p><p>Bob 的计算：<br>Bob 收到 Alice 的公钥 A &#x3D; 19，然    算 A^b mod p：<br>A^b mod p &#x3D; 19^15 mod 29<br>计算 19^15 mod 29：<br>19^15 &#x3D; 41821194261，然后 418211    mod 29 &#x3D; 10<br>所以 Bob 得到的共享密钥是 10。</p><p>步骤 6: 完成<br>最终，Alice 和 Bob 都得到了相同 密钥 10，并且可以用它来进行后续的加密通信。</p><p>看看图解</p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/dh.png" alt="dh"></p><p>来练练手</p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/task4.png" alt="dh"></p><p>三四问可以在<a href="https://www.wolframalpha.com/">这里</a>进行计算</p><p>第一问<br>p&#x3D;29<br>g&#x3D;5<br>a&#x3D;12</p><p>A &#x3D; g^a mod p<br>A &#x3D; 5^12 mod 29<br>A &#x3D; 244140625 mod 29 &#x3D; 7</p><p>第二问 一样<br>b&#x3D;17<br>其他都一样<br>B &#x3D; g^b mod p<br>B &#x3D; 5^17 mod 29 &#x3D; 9</p><p>第三问<br>已知p  &#x3D; 29，a  &#x3D; 12，并且从第二个问题得到B，那么 Bob 计算出的密钥是什么？ </p><p>key &#x3D; B^a mod p<br>key &#x3D; 9^ 12 mod 29 &#x3D;24</p><p>第四问<br>已知p  &#x3D; 29，b  &#x3D; 17，并且从第一个问题得到A，那么 Alice 计算出的密钥是什么？</p><p>key &#x3D; A^b mod p<br>key &#x3D; 7^17 mod 29 &#x3D;24</p><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p>讲的是ssh秘钥</p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/rsa.png" alt="task5"></p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/task5.png" alt="task5"></p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p>数字签名和证书<br>数字签名提供了一种验证数字消息或文档真实性和完整性的方法。数字签名和物理签名​​具有相同的法律效力。</p><p>证书是公钥加密技术的一个重要应用，它们也与数字签名相关。它们最常用于 HTTPS</p><p>证书有一个信任链，从根 CA（证书颁发机构）开始。</p><p>问题就跳过了 文章都是可以找到的</p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p>PGP和GPG<br>PGP代表 Pretty Good Privacy。它是一种实现加密的软件，用于加密文件、执行数字签名等。GnuPG或GPG是 OpenPGP 标准的开源实现。</p><p>看看问题</p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/task77.png" alt="task77"></p><p>需要我们导入密钥 然后解密就可以了</p><p><img src="/source/images/tryhackme-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/public%20key/task7.png" alt="task7"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --import tryhackme.key</span><br><span class="line">gpg --decrypt message.gpg</span><br></pre></td></tr></table></figure><p>到此第二部分也简单介绍到这里</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tryhackme nmap基础介绍</title>
      <link href="/2025/02/10/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/02/10/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/source/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/title.png" alt="title"></p><p>提到Nmap使用多种方式来指定其目标：</p><ul><li><p>IP 范围使用-：如果要扫描从 192.168.0.1 到 192.168.0.10 的所有 IP 地址，就写成192.168.0.1-10</p></li><li><p>IP 子网使用&#x2F;：如果要扫描子网，可以将其表示为192.168.0.1&#x2F;24，这相当于192.168.0.0-255</p></li><li><p>主机名：您还可以通过主机名指定目标，例如，example.thm</p></li></ul><p>更好地控制Nmap如何通过给定端口发现实时主机（例如-PS[portlist]、-PA[portlist]），-PU[portlist]以进行TCP SYN、TCP ACK 和UDP发现。</p><ul><li><p>-sL 此扫描仅列出要扫描的目标，而不会实际扫描它们</p></li><li><p>-sn 目的是发现活动主机而不尝试发现其上运行的服务。</p></li><li><p>-sT 连接扫描  (扫描需要完成tcp三次握手)</p></li><li><p>-sS SYN扫描(仅完成第一步)</p></li><li><p>-sU UDP扫描 (UDP扫描)</p></li><li><p>-F 代表快速模式，扫描 100 个最常见的端口</p></li><li><p>-p[range] 允许您指定要扫描的端口范围。例如，-p10-1024扫描从端口 10 到端口 1024，</p></li><li><p>-p-25 扫描 1 到 25 之间的所有端口。</p></li><li><p>-p- 扫描所有端口和相当于-p1-65535</p></li><li><p>-O 启用操作系统检测。</p></li><li><p>-sV 启用版本检测。这非常方便您用更少的按键收集有关目标的更多信息。发现了几个开放端口，并想知道哪些服务正在监听它们</p></li><li><p>-A 有-O，-sV并且还有更多功能，此选项可实现操作系统检测、版本扫描和跟踪路由等功能。</p></li><li><p>-Pn 能将所有主机视为在线并对每个主机进行端口扫描，包括在主机发现阶段未响应的主机。</p></li><li><p>-T 可以按名称或编号选择计时模板。举例: -T0(或-T 0) 或-T paranoid(paranoid就是计时模板的名称)以选择最慢的计时。</p></li></ul><p>并行探测的数量可以通过–min-parallelism <numprobes>和 来控制–max-parallelism <numprobes>。这些选项可用于设置主机组中同时活动的 TCP 和 UDP 端口探测数量的最小值和最大值。</numprobes></numprobes></p><p>类似有用的选项是–min-rate <number>和–max-rate <number>。顾名思义，它们可以控制nmap发送数据包的最小和最大速率。</number></number></p><ul><li><p>–host-timeout <time>。此选项指定您愿意等待的最大时间，适用于速度较慢的主机或网络连接较慢的主机。</time></p></li><li><p>-v 启用详细输出</p></li><li><p>-d 使用调试级别输出 最高级别是-d9 您可以通过添加一个或多个“d”或直接指定调试级别来提高调试级别</p></li><li><p>oN <filename>- 正常输出</filename></p></li><li><p>oX <filename>- XML输出</filename></p></li><li><p>oG <filename>- -able 输出 (对和grep有用)grepawk</filename></p></li><li><p>oA <basename>- 以所有主要格式输出</basename></p></li></ul><p>随便看看thm的问题</p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/task2.png" alt="task1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sL ip/27</span><br></pre></td></tr></table></figure><p>用-sL列出所有要扫描的目标 找到最后一个就行<br><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/sl%20ip.png" alt="task"></p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/task3.png" alt="task1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT ip</span><br></pre></td></tr></table></figure><p>就能列出所有tcp端口 在这些端口中能发现一个http的端口8008 ip加端口就能获得第二问的flag</p><p><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/tcpport%E7%AB%AF%E5%8F%A3.png" alt="task2"></p><p><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/8008.png" alt="task2"></p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/task4.png" alt="task1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A ip</span><br></pre></td></tr></table></figure><p>用了-A把服务器名称 版本等详细信息都查出来了 慢慢找就行<br><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/web.png" alt="task4"></p><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p>下面就是直接输入就行的 -T的用法</p><p><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/task5.png" alt="task1"></p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p>启用调试是-d<br><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/task6.png" alt="task1"></p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p>在没有root权限 是本地用户的时候只能使用-sT的tcp连接扫描(connect scan)<br><img src="/images/tryhackme-nmap%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/task7.png" alt="task1"></p><p>解决了nmap的基础问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tryhackme &amp; hackthebox Tcpdump小介绍</title>
      <link href="/2025/02/09/tryhatryhackme%20&amp;%20hackthebox%20Tcpdump%E5%B0%8F%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/02/09/tryhatryhackme%20&amp;%20hackthebox%20Tcpdump%E5%B0%8F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tryhackme的tcpdump介绍"><a href="#tryhackme的tcpdump介绍" class="headerlink" title="tryhackme的tcpdump介绍"></a>tryhackme的tcpdump介绍</h1><p>来看看tcpdump这个工具 Tcpdump工具及其libpcap库是用 C 和 C++ 编写的</p><p>tcpdump的作用</p><ul><li>捕获数据包并保存到文件</li><li>对捕获的数据包设置过滤器</li><li>控制捕获的数据包的显示方式</li></ul><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>tcpdump -i INTERFACE</code></td><td>捕获特定网络接口上的数据包</td></tr><tr><td><code>tcpdump -w FILE</code></td><td>将捕获的数据包写入文件</td></tr><tr><td><code>tcpdump -r FILE</code></td><td>从文件读取捕获的数据包</td></tr><tr><td><code>tcpdump -c COUNT</code></td><td>捕获特定数量的数据包</td></tr><tr><td><code>tcpdump -n</code></td><td>不解析 IP 地址</td></tr><tr><td><code>tcpdump -nn</code></td><td>不解析 IP 地址，也不解析协议号</td></tr><tr><td><code>tcpdump -v</code></td><td><code>-vv</code>详细显示；详细程度可以通过和增加<code>-vvv</code></td></tr></tbody></table><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/task2.png" alt="task2"></p><p>答案就是-n</p><h2 id="过滤表达式"><a href="#过滤表达式" class="headerlink" title="过滤表达式"></a>过滤表达式</h2><p>按主机过滤</p><ol><li>指定主机</li></ol><ul><li>host<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.10.1</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>指定源地址和目标地址</li></ol><ul><li>src dst<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 src host 192.168.10.1</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 dst host 192.168.10.1</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>指定端口</li></ol><ul><li>port<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>指定协议</li></ol><ul><li>tcpdump 协议名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 arp</span><br><span class="line">#捕获所有arp协议的数据包</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 icmp</span><br><span class="line">#捕获所有icmp协议的数据包</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 tcp</span><br><span class="line">#捕获所有tcp协议的数据包</span><br></pre></td></tr></table></figure></li></ul><p>tcpdump -i any tcp port 22<br>监听所有接口并捕获tcp往返的数据包port 22，</p><p>tcpdump -i wlo1 udp port 123<br>监听 WiFi 网卡并过滤发往网络时间协议 ( NTPudp ) 的流量。port 123</p><p>tcpdump -i eth0 host example.com and tcp port 443 -w https.pcap<br>将会监听eth0有线以太网接口 ，并过滤与example.com使用tcp和交换的流量port 443。换句话说，此命令正在过滤与相关的 HTTPS 流量example.com。</p><h2 id="高级表达式"><a href="#高级表达式" class="headerlink" title="高级表达式"></a>高级表达式</h2><p>三种计算符 &amp;、|和!(与，或，非)</p><p>可以使用tcp[tcpflags]来引用TCP标志字段。以下TCP标志可供比较：</p><p>tcp-syn TCP SYN（同步）<br>tcp-ack TCP ACK（确认）<br>tcp-fin TCP FIN（完成）<br>tcp-rst TCP RST（重置）<br>tcp-push TCP推送<br>基于上述内容，我们可以写出：</p><p>tcpdump “tcp[tcpflags] &#x3D;&#x3D; tcp-syn”捕获仅设置了 SYN（同步）标志但所有其他标志均未设置的TCP数据包。</p><p>tcpdump “tcp[tcpflags] &amp; tcp-syn !&#x3D; 0”捕获至少设置了 SYN（同步）标志的TCP数据包。</p><p>tcpdump “tcp[tcpflags] &amp; (tcp-syn|tcp-ack) !&#x3D; 0”捕获至少设置了SYN（同步）或ACK（确认）标志的TCP数据包。</p><p>看一下第四部分的题目</p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/task4.png" alt="task4"></p><p>第一问 </p><p>这个就是参数直接套过去就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r traffic.pcap &quot;tcp[flags]==tcp-rst&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/rst.png" alt="task4"></p><p>第二问<br>如果不加-n的话 不会显示主机的ip ip会被解析成主机名 加上-n参数可以直接显示数字格式的 IP 地址和端口号，避免了这些额外的解析过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r traffic.pcap greater 15000  -n</span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/15000.png" alt="task4"></p><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><ul><li>-q：快速输出；打印简要的数据包信息</li><li>-e：打印链接级标题</li><li>-A：以 ASCII 格式显示数据包数据</li><li>-xx：以十六进制格式显示数据包数据，简称hex</li><li>-X：以十六进制和 ASCII 显示数据包头和数据</li></ul><p>来看第五部分的问题</p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/task5.png" alt="task5"></p><p>加个-e参数就能查出mac地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -r traffic.pcap -e arp</span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/arpmac.png" alt="task5"></p><h1 id="hackthebox的tcpdump补充"><a href="#hackthebox的tcpdump补充" class="headerlink" title="hackthebox的tcpdump补充"></a>hackthebox的tcpdump补充</h1><p>话题一转 来看看hackthebox的tcpdump有啥补充吗</p><p>其实讲的也和thm的差不多 简单扩充一下知识点</p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>看看题目</p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/task1.png" alt="htb"></p><p>第一题需要下载个附件 就一张截图 仔细看开头的话 就是一个完整的tcp三次握手流程</p><ul><li>[S] 表示客户端发送的 SYN 包。</li><li>[S.] 表示服务器发送的 SYN-ACK 包。</li><li>[.] 是客户端发送的 ACK 包，完成三次握手。</li></ul><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/question-1.PNG" alt="task1"></p><p>能看到ip192的给ip为174.143.213.184的服务器建立连接</p><p>服务器ip为174.143.213.184</p><p>捕获过程是相对序号</p><p><strong>相对序号</strong> 是一种在抓包过程中为了<strong>简化数据包分析</strong>而使用的序号模式。它将TCP连接中的初始序列号（ISN）归零，从而简化了整个连接中的包的序列号计算。也就是说，所有包的序列号从 0 开始递增，不再显示真实的网络中传输的绝对序列号。</p><p>第三题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rvXc 100</span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/task1.1.png" alt="htb"></p><p>第四题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -Xr /tmp/capture.pcap</span><br></pre></td></tr></table></figure><p>第五题 是-v 还要更详细就-vv</p><p>第六题 man可以看更多信息</p><p>第七题 -W是写入文件</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/task2.png" alt="task2"></p><p>第一问问的蛮好的 -l参数可以通过管道运输到另一个地方</p><p>过滤器确实可以这么做 true</p><p>想要某个协议的数据就直接后面加个协议名<br>不想要某个协议就协议名的前面加个not<br>例如题目问的：not icmp</p><p>问安装在哪可以用which</p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/task2.1.png" alt="task2"></p><p>输出内容更加详细就 -v</p><p>-W 写入文件</p><p>-r 是从中读取捕获的内容</p><p>-X 以十六进制和ascii格式显示内容</p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/task3.png" alt="task3"></p><h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p>这个真的是好问题 琢磨半天了 需要下载他的附件pcap</p><p>一开始我也没怎么看这个包具体咋样 就是直接过滤去找第一个fin包 实际情况是找半天找不出</p><p>这个就是他的pcap包的内容 后面还有一大半</p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/port.png" alt="task"></p><p>那只能老老实实慢慢看 </p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/port1.png" alt="task"></p><p>在这里面，其实有三个端口发出来tcp的第一次握手分别是43804，43806，52520这三个端口 往下看 43804和52520都在最后收到了rst包 而43806成功三次握手</p><p>所以客户端端口应该是43806 而服务端则是http的80端口</p><h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><p>第二问问的是dns服务器ip 那我们得过滤一下 加个port domain参数</p><p>过滤完之后 来检查一下记录</p><p><img src="/images/tryhackme-Tcpdump-The-Basics%E5%B0%8F%E4%BB%8B%E7%BB%8D/htb/dns1.png" alt="dns"></p><p>在这里面我们发现172.16.146.2的57752端口发出请求而下面172.6.46.1收到且回应了</p><p>在前面两个包有a？ aaaa?这种字样 </p><p>在 DNS 请求包中，通常会看到查询字段，比如 A?, AAAA?，表示正在请求域名解析。</p><p>所以172.6.46.1是dns服务器ip</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>感觉还是很遥远哦 才学了这么点东西 </p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tryhackme OWASP Top 10 - 2021上集</title>
      <link href="/2025/02/07/tryhackme-OWASP-Top-10-2021%E4%B8%8A%E9%9B%86/"/>
      <url>/2025/02/07/tryhackme-OWASP-Top-10-2021%E4%B8%8A%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>tryhackme的OWASP Top 10 的题目和记录</p><p>OWASP Top 10 </p><p>访问控制失效<br>加密失败<br>注入<br>不安全的设计<br>安全配置错误<br>易受攻击和过时的组件<br>识别和认证失败<br>软件和数据完整性故障<br>安全日志和监控失败<br>服务端请求伪造（SSRF）</p><h2 id="1-访问控制失效"><a href="#1-访问控制失效" class="headerlink" title="1.访问控制失效"></a>1.访问控制失效</h2><p>攻击者可能通过绕过访问控制机制，获取未授权的资源或执行未授权的操作。</p><p>IDOR 或不安全的直接对象引用是指一种访问控制漏洞，利用该漏洞您可以访问通常无法看到的资源。当程序员公开直接对象引用时就会发生这种情况，它只是指向服务器内特定对象的标识符。我们所说的对象可能是指文件、用户、银行应用程序中的银行账户或任何其他对象。</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task1.png" alt="task1"></p><p>我们进入题目要求的网站 用给的账户登录一下 、</p><p>登进去后会就是显示普通的文本 但观察网址会发现后面有个note_id&#x3D;1这个字样 从零开始输 看看有没有可能出flag<br>第一个就出flag了</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/flag.png" alt="task1"></p><h2 id="2-加密失败"><a href="#2-加密失败" class="headerlink" title="2 加密失败"></a>2 加密失败</h2><p>加密故障是指因误用（或未使用）用于保护敏感信息的加密算法而产生的任何漏洞。Web 应用程序需要加密技术来为其用户提供多层次的机密性。</p><p>加密失败的第二部分 我们简单学习了一下下载数据库和查找数据库的有用信息 还有一个等下用得着的网站<a href="https://crackstation.net/">crackstation</a></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task2.png" alt="task2"></p><p>进入网站查看有什么问题吗</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/web.png" alt="task2"></p><p>看看网站源码<br><img src="/images/tryhackme-OWASP-Top-10-2021/webdb0.png" alt="task2"></p><p>发现有很多都是来自assets 在网址后面加个&#x2F;assets试试看</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/webdb.png" alt="task2"></p><p>看到最后一个数据库文件 把他下过来。然后查看一下数据库里有什么重要文件</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/webdb0.5.png" alt="task2"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/webdb1.png" alt="task2"></p><p>能找到admin的密码的hash值 拉到上面说的网站里面解密能知道明文密码</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/webdb3.png" alt="task2"></p><p>在网站中登录admin账户就能发现flag</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/login.png" alt="task2"></p><h2 id="3-注入"><a href="#3-注入" class="headerlink" title="3 注入"></a>3 注入</h2><p>包括sql注入 命令注入</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task3.png" alt="task3"></p><p>这个thm讲的是命令注入</p><p>先输入$(ls)试试水</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/drpepper.png" alt="task3"></p><p>试试看$(cat &#x2F;etc&#x2F;passwd | grep “usr”)查一下第二题说的用户</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/shell.png" alt="task3"></p><p>但发现都是在&#x2F;sbin中 都属于root用户 所以说是零个用户 用户shell就是&#x2F;sbin&#x2F;shell</p><p>查应用程序以什么用户身份运行？直接whoami</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/whoami.png" alt="task3"></p><p>发现是apache用户</p><p>查版本就 cat &#x2F;etc&#x2F;os-release</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/os-rease.png" alt="task3"></p><p>是3.16.0版本</p><h2 id="4-不安全的设计"><a href="#4-不安全的设计" class="headerlink" title="4 不安全的设计"></a>4 不安全的设计</h2><p>不安全的设计是指应用程序架构固有的漏洞。这些漏洞不是由于糟糕的实现或配置而导致的，而是整个应用程序（或其中的一部分）背后的理念从一开始就存在缺陷。</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task4.png" alt="task4"></p><p>进入网站 直接开始重置账户 选中间那个最喜欢的颜色<br>红黄蓝绿一直输 发现是绿色 重置成功。登录进去就能发现flag</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/green.png" alt="task4"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/greenflag.png" alt="task4"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/greenflag1.png" alt="task4"></p><h2 id="5-安全配置错误"><a href="#5-安全配置错误" class="headerlink" title="5 安全配置错误"></a>5 安全配置错误</h2><p>安全配置错误与其他十大漏洞不同，因为它们发生在安全配置本来可以正确配置但实际上却没有配置的情况下。即使您下载了最新的软件，错误的配置也可能使您的安装变得脆弱。</p><p>先进入网站尝尝<del>咸蛋</del>咸淡<br><img src="/images/tryhackme-OWASP-Top-10-2021/console.png" alt="task5"></p><p>我们直接复制thm给出来的代码 在这里面跑跑</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/tododb.png" alt="task5"></p><p>能发现数据库名字是todo.db</p><p>根据thm的提示 我们稍微改改他给出来的命令 就能查出flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os; print(os.popen(&quot;cat app.py | grep &#x27;flag&#x27;&quot;).read())</span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-OWASP-Top-10-2021/py.png" alt="task5"></p><h2 id="6-易受攻击和过时的组件"><a href="#6-易受攻击和过时的组件" class="headerlink" title="6 易受攻击和过时的组件"></a>6 易受攻击和过时的组件</h2><p>版本不及时更新的话容易遇到一下漏洞攻击</p><p>进入网站看看 诶呦是个线上书店 直接把cse bookstore去谷歌搜索一下看有什么漏洞吗</p><p>挺好 找到一个</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/looudong.png" alt="task"></p><p>那他下载过来 直接跑一遍 漏洞利用成功，cat一下&#x2F;opt&#x2F;flag.txt 就能就能获得flag</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/books.png" alt="task"></p><h2 id="7-身份识别和认证失败"><a href="#7-身份识别和认证失败" class="headerlink" title="7 身份识别和认证失败"></a>7 身份识别和认证失败</h2><p>身份验证和会话管理是现代 Web 应用程序的核心组件。身份验证允许用户通过验证其身份来访问 Web 应用程序。最常见的身份验证形式是使用用户名和密码机制。用户输入这些凭据，然后服务器验证它们。如果它们正确，服务器将向用户的浏览器提供会话 cookie 。需要会话 cookie 是因为 Web 服务器使用HTTP (S) 进行通信，而 HTTP (S) 是无状态的。附加会话 cookie 意味着服务器将知道谁在发送什么数据。然后服务器可以跟踪用户的操作。</p><p>身份验证机制中的一些常见缺陷包括：</p><ul><li>暴力攻击</li><li>使用弱凭证</li><li>弱会话 Cookie。</li></ul><p>看看题目</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task7.png" alt="task7"></p><p>进入网站看看 说是要先注册一个darren的账户 </p><p>你会发现注册darren的话 会说明账户已存在 </p><p>在注册账户的时候 在darren的d的前面加一个空格再来照常注册 发现注册成功 </p><p>用刚才的账户密码就能登录darren账户找到flag</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/login1.png" alt="task7"></p><p>arthur也是一样的操作</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/arthur.png" alt="task7"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/arthur1.png" alt="task7"></p><h2 id="软件和数据完整性故障"><a href="#软件和数据完整性故障" class="headerlink" title="软件和数据完整性故障"></a>软件和数据完整性故障</h2><p>此漏洞源自使用未使用任何完整性检查的软件或数据的代码或基础架构。由于未进行完整性验证，攻击者可能会修改传递给应用程序的软件或数据，从而导致意外后果。此类别中主要有两种类型的漏洞：</p><ul><li>软件完整性故障</li><li>数据完整性故障</li></ul><h3 id="软件完整性故障"><a href="#软件完整性故障" class="headerlink" title="软件完整性故障"></a>软件完整性故障</h3><p>来看看thm的题目 这里讲的是 jQuery<br>如果你愿意，你可以直接从他们的服务器将 jQuery 包含在你的网站中，而无需实际下载它，只需在你网站的 HTML 代码中包含以下行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://code.jquery.com/jquery-3.6.1.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当用户导航到您的网站时，其浏览器将读取其 HTML 代码并从指定的外部源下载 jQuery。</p><p>如果攻击者以某种方式入侵 jQuery 官方存储库，他们可以更改内容<code>https://code.jquery.com/jquery-3.6.1.min.js</code> 以注入恶意代码。</p><p>题目</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task8.0.png" alt="task8"></p><p>将<a href="https://code.jquery.com/jquery-1.12.4.min.js%E8%BD%AC%E6%88%90SHA-256%E7%9A%84%E5%BD%A2%E5%BC%8F">https://code.jquery.com/jquery-1.12.4.min.js转成SHA-256的形式</a></p><p><a href="https://www.srihash.org/">来这里</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://code.jquery.com/jquery-1.12.4.min.js</span><br></pre></td></tr></table></figure><p>进入网站就能转化成SHA-256 这个就答案</p><h3 id="数据完整性故障"><a href="#数据完整性故障" class="headerlink" title="数据完整性故障"></a>数据完整性故障</h3><p>通常，当用户登录应用程序时，他们会被分配某种会话令牌，该令牌需要在会话持续期间保存在浏览器中。此令牌将在每个后续请求中重复，以便 Web 应用程序知道我们是谁。这些会话令牌可以有多种形式，但通常通过 Cookie 分配。Cookie是Web 应用程序将存储在用户浏览器中的键值对，并且将在每次向发出它们的网站发出请求时自动重复。</p><p>如果您正在创建一个 Web 邮件应用程序，您可以在登录后为每个用户分配一个包含其用户名的 Cookie。在后续请求中，您的浏览器将始终在 Cookie 中发送您的用户名，以便您的 Web 应用程序知道哪个用户正在连接。</p><p>因此如果用户篡改 Cookie 并更改用户名，他们可能会冒充其他人并阅读他们的电子邮件！此应用程序将遭受数据完整性故障，因为它信任攻击者可以篡改的数据。</p><p>解决此问题的一个方法是使用某种完整性机制来保证 cookie 未被用户更改。为了避免重复工作，我们可以使用一些允许您执行此操作的令牌实现，并处理所有加密以提供完整性证明，而无需您为此操心。JSON Web 令牌 (JWT)就是这样一种实现。</p><p>看题目</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task8.png" alt="task8"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task8.1.png" alt="task8"></p><p>进入网站 guest随便输入一次 报错就知道密码了</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/cookie.png" alt="task8"></p><p>进去之后f12找出jwt</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/cookieflag.png" alt="task8"></p><p>把hs256改成none 用户名改成admin</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/jwt.png" alt="task8"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/jwt1.png" alt="task8"></p><p>改好的这两个参数重新转化为base64</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/jwt2.png" alt="task8"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/jwt3.png" alt="task8"></p><p>把这个粘贴在一起 用.间隔。最后面也要用.结尾</p><p>把jwt代替之前的jwt 刷新一下就有flag了</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/cookieflag1.png" alt="flag"></p><h2 id="9-安全日志和监控失败"><a href="#9-安全日志和监控失败" class="headerlink" title="9 安全日志和监控失败"></a>9 安全日志和监控失败</h2><p>设置 Web 应用程序时，应记录用户执行的每个操作。记录很重要，因为一旦发生事件，攻击者的活动就会被追踪。一旦追踪到他们的行为，就可以确定他们的风险和影响。如果没有记录，就无法知道攻击者在获得特定 Web 应用程序的访问权限后执行了哪些操作。</p><p>日志中存储的信息应包括以下内容：</p><ul><li>HTTP状态代码</li><li>时间戳</li><li>用户名</li><li>API端点&#x2F;页面位置</li><li>IP 地址</li></ul><p>下载日志看看</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task9.png" alt="task9"></p><p><img src="/images/tryhackme-OWASP-Top-10-2021/log.png" alt="task9"></p><p>看到连续几个相同的ip盲猜就是攻击者ip</p><p>这样看的话就是暴力破解</p><h2 id="10-服务器端请求伪造（SSRF）"><a href="#10-服务器端请求伪造（SSRF）" class="headerlink" title="10 服务器端请求伪造（SSRF）"></a>10 服务器端请求伪造（SSRF）</h2><p>这种类型的漏洞发生在攻击者可以强迫 Web 应用程序代表他们向任意目的地发送请求，同时控制请求本身的内容时。SSRF漏洞通常出现在我们的 Web 应用程序需要使用第三方服务的实现中。</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/task10.png" alt="task10"></p><p>依旧进入网站 发现是个类似博客的东西 周围找找看有什么可以做的吗</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/admin.png" alt="task10"></p><p>点进去发现 要localhost才能进去</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/localhost.png" alt="task"></p><p>第二问 问点击下载按钮。服务器参数指向哪里？</p><p>直接f12 找到下载按钮 发现了下载路径</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/down.png" alt="task"></p><p>这个路径也有大作用 正常来说我们下载那个pdf使用这个路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.10.234.129:8087/download?server=secure-file-storage.com:8087&amp;id=75482342</span><br></pre></td></tr></table></figure><p>我们要把后面的server&#x3D;的值改成attackbox或者是你虚拟机连openvpn的ip 其他都不动</p><p>然后打开终端 设置监听 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 8087</span><br></pre></td></tr></table></figure><p>启动完就把改好的网址在浏览器那搜索一下 终端就能找到flag</p><p><img src="/images/tryhackme-OWASP-Top-10-2021/api1.png" alt="ask"></p><p>于是乎 把thm的owasp top-10简单介绍一下了 过段时间继续学习更新owasp top-1o！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> oaasp 漏洞 tryhackme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tryhackme wireshark入门三部曲</title>
      <link href="/2025/02/04/tryhackme%20wireshark%E5%85%A5%E9%97%A8%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
      <url>/2025/02/04/tryhackme%20wireshark%E5%85%A5%E9%97%A8%E4%B8%89%E9%83%A8%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>wireshark 一个流量分析的工具 一个抓取流量包的工具<br>一个暗藏<del>只因</del>(玄机)的工具 只要擅长使用这个工具能带来很大的帮助 </p><p>简单看看tryhackme的wireshark教程 总共是分为三个部分</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/title.png" alt="title"></p><h1 id="the-basic"><a href="#the-basic" class="headerlink" title="the basic"></a>the basic</h1><p>基础部分当然是介绍解释wireshark的操作界面和基础功能</p><p>先来看看初始界面</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/zhuomian.png" alt="chushi"></p><p>从上往下分别是工具栏，显示过滤栏(用来过滤我们需要的东西)，最近文件，捕获过滤器和接口，状态栏</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/inzhuo.png" alt="in"></p><p>这个界面就是一般我们平时使用的上面红色的部分就是数据包列表，中间的分别是数据包细节和数据包的字节，最下面是告诉我们有几个数据包 以及展示的数据包数目。</p><p>我们来看一下task2 讲了啥东西</p><h2 id="task-2"><a href="#task-2" class="headerlink" title="task 2"></a>task 2</h2><p>Wireshark 是目前最强大的流量分析工具之一。它有多种用途：</p><ul><li>检测并排除网络问题，例如网络负载故障点和拥塞。</li><li>检测安全异常，例如恶意主机、异常端口使用和可疑流量。</li><li>调查和了解协议细节，例如响应代码和有效负载数据。</li></ul><p>科普完毕 来看一下他要求</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/task2.png" alt="task"></p><p>需要我们去查看文件信息 点击这个就可以查看文件信息 我们往下滑就能看到 全部题目的答案</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/st.png" alt="st"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/hash.png" alt="st"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/flag.png" alt="st"></p><p>第一题的flag就在底下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:TryHackMe_Wireshark_Demo</span><br></pre></td></tr></table></figure><p>数据包的总数为58620个 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:57620</span><br></pre></td></tr></table></figure><p>hash值也显而易见</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f446de335565fb0b0ee5e5a3266703c778b2f3dfad7efeaeccb2da5641a6d6eb</span><br></pre></td></tr></table></figure><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/task3.png" alt="task"></p><p>查找数据包的编号先</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/finds.png" alt="task"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/38.png" alt="task"></p><p>可以发现使用了xml语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:eXtensible Markup Language</span><br></pre></td></tr></table></figure><p>看时间的话 就得点进去慢慢找了 其实点进去就能发现到达时间</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/time.png" alt="time"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:13/05/2004</span><br></pre></td></tr></table></figure><p>ttl就是time to live 存活周期 是在osi的第三层 网络层那里 我们就到ip的那个部分找找</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/ttl.png" alt="time"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:47</span><br></pre></td></tr></table></figure><p>tcp的有效负载大小 就得在数据包细节找到tcp的部分 负载应该能理解成一端的大小</p><p>tcp是在第四层 传输层</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/tcp.png" alt="tcp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:424</span><br></pre></td></tr></table></figure><p>etag也在这附近 在底下找找就有了</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/etag.png" alt="tcp"></p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/task4.png" alt="task4"></p><p>查r4w这个字串 的第一个艺术家叫啥名字</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/r4w.png" alt="task4"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/r4w1.png" alt="task4"></p><p>能看到第一个艺术家的名字 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:r4w8173</span><br></pre></td></tr></table></figure><p>去编号是12的数据包那看评论是啥 这个就有意思了 </p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet1.png" alt="task4"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet2.png" alt="task4"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/12.png" alt="task4"></p><p>又让我去39765这个包里面找照片 一开始我是没想到这东西还能直接导出来 后面有一个note.txt也是一样 要我们导出来 cat一下就行 照片就不太一样 他说了要md5 我们用md5sum来把他提取出来</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/img.png" alt="task4"></p><p>导出之后直接md5sum 加你保存的文件名</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/md5.png" alt="task4"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:911cd574a42865a956ccde2d04495ebf</span><br></pre></td></tr></table></figure><p>需要找一个txt文件 先用过滤器去过滤一下 找到txt文件在哪</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/note0.png" alt="task4"></p><p>然后我们导出http 把note.txt导出来</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/note.png" alt="task4"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/note2.png" alt="task4"></p><p>保存之后 我们直接查看就能看到外星人名字</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/name.png" alt="task4"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:packermaster</span><br></pre></td></tr></table></figure><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/task5.png" alt="task5"></p><p>第一题就是http</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans：http</span><br></pre></td></tr></table></figure><p>第二题我们过滤了http之后 在底下会有显示展示了多少个数据包</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/http.png" alt="shujubao"></p><p>下面显示1089个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans:1089</span><br></pre></td></tr></table></figure><p>第三题 去到33790的包中查看一下细节</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/secend.png" alt="shujubao"></p><p>进http流里面搜索artists 就能看到艺术家名字 会发现艺术家共有三个 第二个叫做Blad3</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/band.png" alt="shujubao"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ans:3</span><br><span class="line"></span><br><span class="line">ans:Blad3</span><br></pre></td></tr></table></figure><p>第一个部分 基础部分结束了 我们来看下一个部分</p><h1 id="Packet-Operations"><a href="#Packet-Operations" class="headerlink" title="Packet Operations"></a>Packet Operations</h1><p>数据包操作 我们来看点小难的来练练 主要也是深入了解一点wireshark</p><p>这个地方是统计 可以看协议的数据包 主要是对数据包进行统计 可以在里面找到你想要的数据包</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/ipvx.png" alt="qwe"></p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/task2.png" alt="task2"></p><p>第一题我们得在resolved addresses里面去找 因为是在找hostname是bbc的ip</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/bbc.png" alt="task2"></p><p>ip为199.232.24.81</p><p>第二题是在找ipv4的对话 那我们要在对话里面去找ipv4</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/ipv4.png" alt="task2"></p><p>共有435个对话</p><p>第三题 这次我们现在resolved addresses找一下micro-st的地址 然后去endpoint查询这个地址的字节</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/micro.png" alt="task2"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/mac.png" alt="task2"></p><p>这两招下来就能找到字节大小 7474bytes</p><p>第三题依然是在endpoints里面找 找到city 筛选一下。能找到四个Kansas City有关的地址</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/city.png" alt="city"></p><p>第四题在endpoints 里面找组织 也是筛选一下 就能知道ip是188.246.82.7</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/blicnet.png" alt="city"></p><h2 id="task3-1"><a href="#task3-1" class="headerlink" title="task3"></a>task3</h2><p>直接看题目要求</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/task3.png" alt="task3"></p><p>第一问 问最多用的ipv4的目的地址</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/destination.png" alt="task3"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/destination1.png" alt="task3"></p><p>ip为10.100.1.33 我搞不懂为啥前面还多一个 看格式就是第二个 第一个不知道咋蹦出来的</p><p>第二问 我们还是在熟悉的地方 就是statistics 统计这 点开dns</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/ipvx.png" alt="task3"></p><p>在这找到services里的request-response time 能看到时间 0.467897</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/dns1.png" alt="task3"></p><p>第三rad.msn.com的http Requests </p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/http.png" alt="task3"></p><p>你会发现有两个rad.msn.com 直接相加就完事了</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/http1.png" alt="task3"></p><h2 id="task4-1"><a href="#task4-1" class="headerlink" title="task4"></a>task4</h2><p>这个是科普环节 将怎么使用wireshark的过滤器</p><h3 id="捕获过滤器"><a href="#捕获过滤器" class="headerlink" title="捕获过滤器"></a>捕获过滤器</h3><table><thead><tr><th>过滤规则</th><th>说明</th></tr></thead><tbody><tr><td><code>host 192.168.1.1</code></td><td>仅捕获来自或发送到 192.168.1.1 的数据包</td></tr><tr><td><code>net 192.168.1.0/24</code></td><td>仅捕获 192.168.1.0&#x2F;24 子网的数据包</td></tr><tr><td><code>port 80</code></td><td>仅捕获端口 80（HTTP）的流量</td></tr><tr><td><code>tcp</code></td><td>仅捕获 TCP 数据包</td></tr><tr><td><code>udp</code></td><td>仅捕获 UDP 数据包</td></tr><tr><td><code>tcp port 443</code></td><td>仅捕获 TCP 端口 443（HTTPS）的流量</td></tr><tr><td><code>src host 10.0.0.1</code></td><td>仅捕获源 IP 为 10.0.0.1 的流量</td></tr><tr><td><code>dst port 53</code></td><td>仅捕获目标端口为 53（DNS）的数据包</td></tr></tbody></table><h3 id="显示过滤器"><a href="#显示过滤器" class="headerlink" title="显示过滤器"></a>显示过滤器</h3><table><thead><tr><th>过滤规则</th><th>说明</th></tr></thead><tbody><tr><td><code>ip.addr == 192.168.1.1</code></td><td>过滤与 192.168.1.1 相关的所有流量</td></tr><tr><td><code>ip.src == 10.0.0.1</code></td><td>仅显示源 IP 为 10.0.0.1 的数据包</td></tr><tr><td><code>ip.dst == 8.8.8.8</code></td><td>仅显示目标 IP 为 8.8.8.8 的数据包</td></tr><tr><td><code>tcp.port == 80</code></td><td>仅显示 TCP 端口 80 的流量</td></tr><tr><td><code>udp.port == 53</code></td><td>仅显示 UDP 端口 53（DNS）的流量</td></tr><tr><td><code>http</code></td><td>仅显示 HTTP 流量</td></tr><tr><td><code>dns</code></td><td>仅显示 DNS 流量</td></tr><tr><td><code>tcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 0</code></td><td>仅显示 TCP SYN 包（新建连接）</td></tr><tr><td><code>frame contains &quot;password&quot;</code></td><td>仅显示数据包内容包含 “password” 的数据包</td></tr><tr><td><code>eth.addr == aa:bb:cc:dd:ee:ff</code></td><td>仅显示特定 MAC 地址的流量</td></tr></tbody></table><h2 id="task5-1"><a href="#task5-1" class="headerlink" title="task5"></a>task5</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/task5.png" alt="task3"></p><p>第一问 我们直接在过滤器里面输入ip就能知道 共81420个数据包</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/ip.png" alt="ip"></p><p>第二问 问我们ttl值小于10的数据包有几个 能查到有66个</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/ttl.png" alt="ttl"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.ttl&lt;10</span><br></pre></td></tr></table></figure><p>第三问 端口是4444的tcp数据包有几个</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/tcp4444.png" alt="4444"></p><p>有632个数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.port ==4444</span><br></pre></td></tr></table></figure><p>第四问 80端口的http get数据包有几个</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/tcp%2080.png" alt="tcp 80"></p><p>共527个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method=&quot;GET&quot; &amp;&amp; tcp.port==80</span><br></pre></td></tr></table></figure><p>第五问 dns a级查询</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/dnsa.png" alt="tcp 80"></p><p>用这个查询会发现 这个数字并不是题目要求</p><p>我们看一下显示过滤器</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/dns2.png" alt="tcp 80"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/dnsaa.png" alt="tcp 80"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/dnsa.png" alt="tcp 80"></p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/task6.png" alt="task6"></p><p>ok 第一问找不是80端口的iis服务器的数据包 这里是两个条件 一个是iis服务器 一个是不能是80端口</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/port80%20.png" alt="ask"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.server contains &quot;iis&quot; &amp;&amp; tcp.scrcport= 80 </span><br></pre></td></tr></table></figure><p>就能筛选出来 共有21个</p><p>第二问 找到所有版本是7.5的iis服务器</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/7.5.png" alt="iis"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.server contains &quot;iis&quot; &amp;&amp; http.server contains &quot;7.5&quot; </span><br></pre></td></tr></table></figure><p>用这个命令就能筛选出来 共71个</p><p>第三问 3333，,4444，,9999端口共有几个数据包</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/3333.png" alt="sidan"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.port in &#123;3333 4444 9999&#125;</span><br></pre></td></tr></table></figure><p>共计2235个数据包</p><p>第四问<br>ttl为偶数的数据包个数</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/ttl1.png" alt="ttl"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings(ip.ttl) matches &quot;[02468]$&quot;</span><br></pre></td></tr></table></figure><p>过滤出来能发现有77289个数据包</p><p>第五问<br>这个要去改config文件 改完使用专家视图去查看</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/config.png" alt="config"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/config1.png" alt="config"></p><p>改完之后就可以去专家视图那边去查看Bad TCP Checksum的个数</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/config3.png" alt="config"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/config4.png" alt="config"></p><p>最后一问<br>总算是轻松一点了<br>用已经存在的过滤器来筛选数据包  轻轻松松 能发现261个  </p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/packet/5.png" alt="shujubao"></p><p>这两个wireshark就写到这里 收益还是很多的 在筛选器那里和导出文件 对wireshark的功能也熟悉了很多 至少不会像之前一样两眼懵逼的盯着屏幕<br>现在剩下最后一个问题了 流量分析！！！</p><h2 id="traffic-Analysis"><a href="#traffic-Analysis" class="headerlink" title="traffic Analysis"></a>traffic Analysis</h2><p>前面的看完 我们看看流量分析</p><p>这个是真有点小难度</p><h2 id="task2-1"><a href="#task2-1" class="headerlink" title="task2"></a>task2</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task2.png" alt="task2"></p><h3 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h3><p>其实在这个文章中就有介绍怎么去过滤tcp connect的数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.flags.syn==1 and tcp.flags.ack==0 and tcp.window_size &lt;= 1024</span><br></pre></td></tr></table></figure><ul><li>syn &#x3D;&#x3D; 1就是用来确立连接的请求报文  </li><li>ack&#x3D;&#x3D;0就是三次握手的第一步 </li><li>tcp窗口的大小字段小于等于1024</li></ul><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/tcp%20connect.png" alt="ask1"></p><p>由图就能看出总数为1000个</p><h3 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h3><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/tcpconnect.png" alt="ask2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 80</span><br></pre></td></tr></table></figure><p>第一个包会发现是tcp connect的数据包</p><h3 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h3><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/udpguabi.png" alt="ask3"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icmp.type == 3 &amp;&amp; icmp.code == 3</span><br></pre></td></tr></table></figure><p>icmp.type &#x3D;&#x3D; 3意思就是目的地不可达</p><p>icmp.code &#x3D;&#x3D; 3意思就是端口不可达</p><p>这样就能查出有1083个关闭的端口</p><h2 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/udp1.png" alt="ask4"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp.port in &#123;55..70&#125;</span><br></pre></td></tr></table></figure><p>我们过滤出来之后分析一下这个数据包走向 前面67和69端口的数据包后面都显示没到达目的地 而68端口则显示成功 数据包一直在传输。说明68端口开放</p><h2 id="task3-2"><a href="#task3-2" class="headerlink" title="task3"></a>task3</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task3.png" alt="task3"></p><h3 id="第一问-1"><a href="#第一问-1" class="headerlink" title="第一问"></a>第一问</h3><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/284.png" alt="ask1"></p><p>我们仔细观察就能发现攻击者的物理地址 就图片蓝色标的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arp.opcode== 1) &amp;&amp; (eth.src == 00:0c:29:e2:18:b4)</span><br></pre></td></tr></table></figure><p>arp.opcode &#x3D;&#x3D; 1 就是过滤arp请求包</p><p>其实单点一下你要的选项 把他拖到搜索栏那里就能自动输入 没有这么麻烦 就这个问题举例子 点到源地址这个选项 单击拖到搜索栏 选择and selected 就能自动输入</p><h3 id="第二问-1"><a href="#第二问-1" class="headerlink" title="第二问"></a>第二问</h3><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/httppacket.png" alt="ask2"></p><p>这题是说攻击者收到的http包的数目 意思就是目的地应该是攻击者的地址才对 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(http) &amp;&amp; (eth.dst == 00:0c:29:e2:18:b4)</span><br></pre></td></tr></table></figure><h3 id="第三问-1"><a href="#第三问-1" class="headerlink" title="第三问"></a>第三问</h3><p>问用户名和密码的话 八层应该是与登录有关 我们搜一下关键词login 随便点进去看到有个可疑的值 uname和pass</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/number6.png" alt="ask3"></p><p>把uname值拖到搜索栏搜一下 就能找到六个账户密码的条数</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/6.png" alt="ask3"></p><h3 id="第四问-1"><a href="#第四问-1" class="headerlink" title="第四问"></a>第四问</h3><p>问一个账户的密码 我们就在上一题的地方找到Client986这个账户 在里面就能翻到密码clientnothere!</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/client986.png" alt="ask4"></p><h3 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h3><p>我们在上一题找到Client986 我们把这个值拖到搜索栏 把Client986改成Client354 就能搜到与Client354有关的数据包 进去后在周围翻翻就能找到密码</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/nice354.png" alt="ask5"></p><p>在周围翻翻就能找到密码</p><h2 id="task4-2"><a href="#task4-2" class="headerlink" title="task4"></a>task4</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task4.png" alt="task4"></p><h3 id="第一问-2"><a href="#第一问-2" class="headerlink" title="第一问"></a>第一问</h3><p>问主机盖乐世a30的mac地址 那我们搜搜看有没有数据包有a30这个字段的</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/a30.png" alt="ask1"></p><p>找到之后往上面找找地址 destination地址是cisco思科的企业协议 源地址估计就是我们想要的</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/a301.png" alt="ask1"></p><h3 id="第二问-2"><a href="#第二问-2" class="headerlink" title="第二问"></a>第二问</h3><p>问工作站的netbios注册请求</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/lival.png" alt="ask2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbns.name contains &quot;LIVALJM&quot; &amp;&amp; nbns.flags opcode == 5 </span><br></pre></td></tr></table></figure><p>nbns.flags opcode &#x3D;&#x3D; 5 表示nbns的注册请求</p><h3 id="第三问-2"><a href="#第三问-2" class="headerlink" title="第三问"></a>第三问</h3><p>问哪个主机请求的ip是172.16.13.85</p><p>我们先搜一下dhcp 看一下数据包先 在最底下发现一行requested ip address 把这个值拖到搜索栏和dhcp一起搜索<br>记得加上我们题目说的ip</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/a12.png" alt="ask3"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(dhcp) &amp;&amp; (dhcp.option.requested_ip_address == 172.16.13.85)</span><br></pre></td></tr></table></figure><p>一搜一个准 找到主机名 盖乐世的a12</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/a121.png" alt="ask3"></p><h3 id="第四问-2"><a href="#第四问-2" class="headerlink" title="第四问"></a>第四问</h3><p>找u5这个用户的ip </p><p>CNameString在kerberos中就算是用户名 把这个参数拉到搜索栏 搜u5就行了</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/u5.png" alt="ask4"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/u51.png" alt="ask4"></p><p>我这算很繁琐的步骤 用下面这个命令就一步到位了 知道ip是10.1.12.2 诶 要记住不能只填ip 他说是defanged ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos.CNameString contains &quot;u5&quot;</span><br></pre></td></tr></table></figure><p>科普一下<br>Defanged IP address”（去毒化的 IP 地址）是一种安全处理技术，于修改 IP 地址的显示格式，使其在文档、日志或安全报告中不被自动识别为可点击的链接，从而防止意外访问或自动化攻击。</p><p>把.换成[.]就行了</p><h3 id="第五问-1"><a href="#第五问-1" class="headerlink" title="第五问"></a>第五问</h3><p>要查主机名 在kerberos中主机名和用户名有点小区别</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/user.png" alt="ask5"></p><p>就得在后面加个$ 所以我们就查CNameString带$的就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos.CNameString contains &quot;$&quot; </span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/xp1.png" alt="ask5"></p><p>查到了一个叫xp1$的用户名</p><h2 id="task5-2"><a href="#task5-2" class="headerlink" title="task5"></a>task5</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task5.png" alt="task5"></p><h3 id="第一问-3"><a href="#第一问-3" class="headerlink" title="第一问"></a>第一问</h3><p>问什么协议<br>这题其实我来说没多大灵感 就搜icmp然后往下翻翻 看看有哪个包的大小异常吗 结果发现还真有 点开看看 发现开头就发现了dh协议 ssh敲定了<br><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/ssh.png" alt="ask1"></p><h3 id="第二问-3"><a href="#第二问-3" class="headerlink" title="第二问"></a>第二问</h3><p>开始就是搜索dns看看有什么大小异常的包吗 还是出乎意料 真有一个</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/data.png" alt="ask2"></p><p>底下发下一个网站 把网址中的.转化成[.] 输进去发现成了</p><p>这两个纯纯狗屎运</p><h2 id="task6-1"><a href="#task6-1" class="headerlink" title="task6"></a>task6</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task6.png" alt="task2"></p><h3 id="第一问-4"><a href="#第一问-4" class="headerlink" title="第一问"></a>第一问</h3><p>问有几次登录失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp.response.code == 530</span><br></pre></td></tr></table></figure><p>530：未登录，密码无效 刚好适合错误的登录尝试</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/error737.png" alt="ask1"></p><h3 id="第二问-4"><a href="#第二问-4" class="headerlink" title="第二问"></a>第二问</h3><p>问的是文件大小 应该是和文件状态有关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp.response.code == 213</span><br></pre></td></tr></table></figure><p>213：文件状态</p><p>输完命令之后我们点开追踪流检查一下</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/213.png" alt="ask2"></p><p>发现有个39424大小的文件</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/2131.png" alt="ask2"></p><h3 id="第三问-第四问"><a href="#第三问-第四问" class="headerlink" title="第三问 &amp; 第四问"></a>第三问 &amp; 第四问</h3><p>问文件名和升级文件权限的命令。<br>同样在这个追踪流里面可以看到。<br><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/chmod.png" alt="ask2"></p><p>文件和命令都看见了。</p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task7.png" alt="task2"></p><h3 id="第一问-第二问"><a href="#第一问-第二问" class="headerlink" title="第一问&amp;第二问"></a>第一问&amp;第二问</h3><p>这一问纯玄学 问异常的类型<br><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jizhong.png" alt="ask1"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jizhong2.png" alt="ask1"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jizhong4.png" alt="ask1"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jizhong5.png" alt="ask1"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jizhong6.png" alt="ask1"></p><p>最后一个是mozilla和mozllla差了个字</p><p>第二题刚好问了这个有差别的包的编号是什么 第52个</p><h3 id="第三问-第四问-1"><a href="#第三问-第四问-1" class="headerlink" title="第三问&amp;第四问"></a>第三问&amp;第四问</h3><p>第几个包发动log4j攻击的</p><p>问了问度娘<br>Log4j 是一个广泛使用的 Java 日志记录库，jndi（Java 命名和目录接口）是 Java 的一部分，允许 Java 应用程序查找和访问命名服务。</p><p>输入命令搜一下 出现的第一个是编号444的包 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip contains &quot;jndi&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jndi.png" alt="aks3"></p><p>点进去发现一个惊喜 应该是base64编码 拉到cyberchief里面解码<br><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jndi1.png" alt="aks3"></p><p>会发现在用wegt下载 设置权限 运行脚本 把ip转成defang的ip 就是第四题的答案<br><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/jizhong3.png" alt="ask1"></p><h2 id="task8"><a href="#task8" class="headerlink" title="task8"></a>task8</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task8.png" alt="task2"></p><h3 id="第一问-5"><a href="#第一问-5" class="headerlink" title="第一问"></a>第一问</h3><p>问发送到“accounts.google.com”的“Client Hello”消息的框架编号是多少？</p><p>Client Hello：tls.handshake.type &#x3D;&#x3D; 1<br>server Hello： tls.handshake.type &#x3D;&#x3D; 2  </p><p>我们先收集一下所有的Client Hello 随便点一个点开他的server name 拉到搜索栏 server name改成‘accounts.google.com’<br><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/client.png" alt="ask1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tls.handshake.type == 1)  &amp;&amp; (tls.handshake.extensions_server_name == &quot;accounts.google.com&quot;)</span><br></pre></td></tr></table></figure><p>一下就搜出来了</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/16.png" alt="ask1"></p><h3 id="第二问-5"><a href="#第二问-5" class="headerlink" title="第二问"></a>第二问</h3><p>导入秘钥 直接搜http2就出来了 共115个</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/http2.png" alt="ask2"></p><h3 id="第三问-3"><a href="#第三问-3" class="headerlink" title="第三问"></a>第三问</h3><p>去322编号的数据包</p><p>直接点开跟踪流 把网站的.弄成[.]</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/322.png" alt="ask3"></p><h3 id="第四问-3"><a href="#第四问-3" class="headerlink" title="第四问"></a>第四问</h3><p>找这种数据包里的文件有个很diao的方法 我们导出文件</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/flag0.png" alt="ask4"></p><p>点进去就能找到疑似flag的包</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/flag.png" alt="ask4"></p><p>保存到桌面 查看一下就行了</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/flag1.png" alt="ask4"></p><h2 id="task9"><a href="#task9" class="headerlink" title="task9"></a>task9</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task9.png" alt="task2"></p><h3 id="第一问-第二问-1"><a href="#第一问-第二问-1" class="headerlink" title="第一问&amp;第二问"></a>第一问&amp;第二问</h3><p>明文凭证 这一问都是在这里面完成</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/cred.png" alt="ask"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/cred1.png" alt="ask"><br>第一问的数据包编号就是237</p><p>第二个就得看看数据包先 </p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/ftp1.png" alt="ask"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/ftp2.png" alt="ask"></p><p>数据包基本就分这两类 user和pass 还有别的无关紧要的 要求是说空密码 就把 request command：pass那行拉去搜索</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/ftp.png" alt="ask"></p><p>发现第170个包的pass空空的 没错了</p><h2 id="task10"><a href="#task10" class="headerlink" title="task10"></a>task10</h2><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/task10.png" alt="task2"></p><p>照着题目点击对应的数据包 点开防火墙规则设置</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/fire0.png" alt="ask"></p><p>把这两个规则复制粘贴就行 第二问要把deny改成allow 因为题目问的是允许</p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/fire.png" alt="ask"></p><p><img src="/images/tryhackme-wireshark%E5%B0%8Ftips/traffic/fire2.png" alt="ask"></p><p>wireshark三个部分总算肝完 其实也不算肝 就是内容小多 内容也干得要死 全是干货 过段时间更一下wireshark的实战 试试水</p>]]></content>
      
      
      
        <tags>
            
            <tag> wireshark 基础 渗透工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lookup 教程</title>
      <link href="/2025/01/31/lookup-%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/31/lookup-%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lookup-教程"><a href="#lookup-教程" class="headerlink" title="lookup 教程"></a>lookup 教程</h1><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/head.png" alt="lookup"></p><p>这次来了个lookup 话不多说 直接看题</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/title.png" alt="lookup"></p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>我们还是绑一下域名 就是在&#x2F;etc&#x2F;hosts里面输你的机器ip 加lookup.thm</p><p>这个就不上图了 记得顺便把file.lookup.thm也绑一下hosts 不然等下登录进去就会发现登不进去</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/fail.png" alt="file"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>我们访问lookup.thm 发现是个登录界面 先随便输几个试试水 经过发现会有两个提示 第一个是密码错误 第二个是密码和账户都错误 用hydra来搞一下 看看能破解出来吗 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hydra -l admin -P /usr/share/wordlists/rockyou.txt lookup.thm http-post-form  &quot;/login.php:username=^USER^&amp;password=^PASS^:Wrong Password. Please try again&quot;</span><br><span class="line"></span><br><span class="line">hydra -L /usr/share/wordlists/rockyou.txt -p password123 lookup.thm http-post-form  -vV &quot;/login.php:username=^USER^&amp;password=^PASS^:Wrong username or password. Please try again.&quot;</span><br></pre></td></tr></table></figure><p>通过第一个代码 能够爆出密码是晒 第二个代码可以把账户名也搞出来</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/password.png" alt="hydra"></p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/password2.png" alt="hydra"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>破解出密码之后 我们登录进去看看怎么个事 发现是个类似文件夹的管理系统 文件基本上都是上锁了 看看没解锁的文件有啥提示吗 </p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/file1.png" alt="lock"></p><p>好吧 也没提示啥 偶然发现了这个文件夹是elfinder 版本号也知道 搜一下看有漏洞吗 发现是有的 我们打开msf 搜一下这个漏洞</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/banbaen.png" alt="lock"></p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/msf.png" alt="msf"></p><p>配置一下rhost和lhost这两个参数 一个是你要攻击的域名 一个是你本机的ip run一下 我们成功打进去了</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/msf1.png" alt="msf"></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>这个有有点困难了 要提权 先find &#x2F;–perm 4000 2&gt;&#x2F;dev&#x2F;null 查看suid用户 发现一个叫pwn的用户 感觉这个是解题关键 ls查看一下详细信息 所属root </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /--perm 4000 2&gt;/dev/null </span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;dev&#x2F;null 表示将标准错误输出重定向到 &#x2F;dev&#x2F;null，这相当于丢弃错误信息。</p></blockquote><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/pwn.png" alt="shell"></p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/pwn2.png" alt="shell"></p><p>输入&#x2F;usr&#x2F;sbin&#x2F;pwm 他告诉我们提示 输入ip 会显示用户名 我们就得想办法的让他爆名字 输入id这个命令能知道用户名</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/id.png" alt="shell"></p><p>我们在&#x2F;tmp中搞一个id的文本文件 id think用户 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;#!/bin/bash\n echo &quot;uid=33(think) gid=33(think) groups=33(think)&quot;&#x27; &gt; id</span><br></pre></td></tr></table></figure><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/think.png" alt="shell"></p><p>别忘了给这个id文件加上可执行的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x id</span><br></pre></td></tr></table></figure><p>然后修改一下环境变量 将 &#x2F;tmp 目录添加到 PATH 变量的最前面。系统在查找可执行文件时，会首先查找 &#x2F;tmp 目录中的文件。</p><p>如果 &#x2F;tmp 目录中有可执行文件，直接输入命令时，系统会优先在 &#x2F;tmp 中寻找该命令。</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/export.png" alt="shell"></p><p>重新运行&#x2F;usr&#x2F;sbin&#x2F;pwm 就能看到爆出来了一堆密码(没猜错就是密码)</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/jose1.png" alt="shell"></p><p>把这些复制下来 粘贴到一个文本文档中 做成一个密码本 用户名为think 用hydra爆破ssh的密码 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l think -P /path/你的密码本文件名 ssh://lookup.thm</span><br></pre></td></tr></table></figure><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/mima.png" alt="shell"></p><p>用这个用户名和密码就能成功ssh连接上think这个用户 然后直接ls就能查看到user.txt</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/user.png" alt="mima"></p><p>成功爆破 还有一个root用户还没解决 我们sudo -l查看能运行什么命令 有个look 我们到这里<a href="https://gtfobins.github.io/gtfobins/">GTFOBins</a> 搜索look </p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/sudo.png" alt="mima"></p><p>这也是个漏洞 让他爆出root的秘钥</p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/look2.png" alt="mima"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LFILE = /root/.ssh/id_rsa </span><br><span class="line"></span><br><span class="line">sudo look &#x27;&#x27;  “ $LFILE ”</span><br></pre></td></tr></table></figure><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/look.png" alt="mima"></p><p>最后把 秘钥粘贴到一个文本文件中  成功登录 ls就能看到root.txt 第二问解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i 文件名 root@lookup.thm</span><br></pre></td></tr></table></figure><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/ssh.png" alt="mima"></p><p><img src="/images/lookup-%E6%95%99%E7%A8%8B/root.png" alt="mima"></p><p>lookup只能说很细节 用了msf hydra 提权 提权还是不懂 我都是网站找的python的搞 这个纯纯弱项了 还有hydra也折腾了好久 本来是rockyou.txt一直梭 但一直不出 换了好几个用户名的字典 才把用户名搞出来<br>要破解网站要加这个”username&#x3D;^USER^&amp;password&#x3D;^PASS^:网页输错的提示”一开始是很不理解为啥这样的 这个网站一个是密码和用户名全错 一个是用户名错 就用这个提示把密码筛选出来 然后用密码破用户名 学的东西还挺多的</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network 网络概念</title>
      <link href="/2025/01/31/network-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/01/31/network-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络知识的介绍"><a href="#网络知识的介绍" class="headerlink" title="网络知识的介绍"></a>网络知识的介绍</h1><h2 id="osi七层模型"><a href="#osi七层模型" class="headerlink" title="osi七层模型"></a>osi七层模型</h2><p>OSI 模型是一个描述网络功能的概念框架。简单来说，OSI 模型标对计算机系统彼此之间发送信息的方式进行了标准化。</p><p>分为：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ul><p><img src="/images/network-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/osi.png" alt="osi"></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><strong>物理层</strong>（Physical Layer）是计算机网络OSI模型中<strong>最低</strong>的一层，也是<strong>最基本</strong>的一层。简单的说，网络的物理层面确保<strong>原始的数据</strong>可在各种<strong>物理媒体</strong>上<strong>传输</strong>。</p><p>物理层规定：为传输数据，需要<strong>物理链路</strong>与<strong>设备</strong>的建立、维持、拆除，并具有<strong>机械的</strong>、<strong>电子的</strong>、<strong>功能的</strong>、<strong>规范</strong>的特性。</p><p>第一层的数据单元是<strong>比特</strong>（bit）。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>为数据段设备提供传输数据的通路</p></li><li><p>传输数据</p></li></ol><h4 id="常见物理层设备"><a href="#常见物理层设备" class="headerlink" title="常见物理层设备"></a>常见物理层设备</h4><ul><li>光纤</li><li>CAT-5线</li><li>CAT-6线</li><li>CAT-7线</li><li>RJ-45接头</li><li>集线器</li><li>串口</li><li>并口</li></ul><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ul><li>曼彻斯特编码 </li><li>差分曼彻斯特编码</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层（Data Link Layer）是OSI参考模型<strong>第二层</strong>，位于物理层与网络层之间。可以细分成<strong>介质访问控制（MAC）子层</strong>和<strong>逻辑链路控制（LLC）子层</strong>。</p><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>数据链路层用于跨物理层在<strong>网段节点</strong>之间传输数据，通常指以太网、无线局域网等通信手段。数据链路层提供了在网络的两个实体之间传输数据的功能，并且提供了<strong>差错检测</strong>用于<strong>纠正</strong>物理层中发生的错误。</p><p>只提供导线的一端到另一端（本质是点到点）的<strong>数据传输</strong>。</p><p>数据链路层的以太网协议规定了一组二进制电信号为<strong>数据帧</strong>，数据帧的报头 head 就包含<strong>目标 MAC 地址</strong>和<strong>源 MAC 地址</strong></p><p>第二层的数据单元是 <strong>帧</strong>（frame）。</p><p>帧都包括一个帧头 主题和一个帧尾</p><ul><li>帧头：源节点和目的节点的mac地址</li><li>主体：要传输的比特</li><li>帧尾：包括错误检测信息</li></ul><h4 id="常见数据链路层的设备"><a href="#常见数据链路层的设备" class="headerlink" title="常见数据链路层的设备"></a>常见数据链路层的设备</h4><ul><li>网卡（物理层和数据链路层的MAC子层）</li><li>交换机 是数据链路层设备。</li><li>桥接器（又称网桥）</li></ul><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>异步传输模式</p><ul><li><p>VLAN（IEEE 802.1Q）</p></li><li><p>以太网（IEEE 802.3）</p></li><li><p>Wi-Fi（IEEE 802.11）</p></li><li><p>PPP协议<br>点对点协议 一种数据链路层封装协议 有PAP和CHAP两种方式</p></li><li><p>PPPoE协议<br>，以太网上的点对点协议，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的一种网络隧道协议。</p></li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>实际的传输功能就在网络层</p><p>网络层是<strong>互联网通信过程</strong>的一部分，这是连接发生的地方，在不同网络之间来回<strong>发送数据包</strong>来进行通信，处理不同网络之间的数据路由和发送。</p><p>用于将接收到的数据段从一台计算机传输到位于不同网络中的另一台计算机。</p><p>第三层的数据单元为<strong>数据包</strong></p><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ol><li>寻址<br>对网络层而言使用IP地址来<strong>唯一标识</strong>互联网上的各个寻址，网络层依靠IP地址进行<strong>相互通信</strong>（类似于MAC地址），详细的编址方案参见IPv4和IPv6。<br></li><li>路由<br>在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li></ol><h4 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h4><ul><li>IP （V4、V6）</li><li>ICMP（V4、V6）</li><li>IPsec</li><li>RIP</li><li>OSPF</li></ul><h4 id="ip协议"><a href="#ip协议" class="headerlink" title="ip协议"></a>ip协议</h4><p>网络层最常使用这个协议。IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（最大传输单元。以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>主机号</li><li>网络号</li></ul><h4 id="具有网络层功能的设备"><a href="#具有网络层功能的设备" class="headerlink" title="具有网络层功能的设备"></a>具有网络层功能的设备</h4><ul><li>路由</li><li>三层交换机</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层并不负责将数据从一个设备传输到另一个设备 是作为数据传输的一个媒介 帮助应用到应用的通信</p><p>传输层通过分段、流量控制和差错控制来控制通信的可靠性。支持不同主机上运行的应用程序之间的端到端通信。</p><p>第四次的数据单元可以说<strong>报文段</strong>或<strong>数据段</strong>(<strong>tcp</strong>)和<strong>数据报</strong>(<strong>udp</strong>)</p><h4 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h4><ul><li>tcp</li><li>udp</li></ul><p>tcp比udp多出很多特征 流量控制，超时重传等</p><p>传输层的数据包超过tcp最大报文段长度，就要将数据包分段 称之为tcp segment(tcp段)</p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>主要利用传输层提供的端到端数据传输服务，为两个会话层实体进行<strong>会话</strong>（Session），而进行的对话连接的管理服务。</p><h4 id="会话层服务"><a href="#会话层服务" class="headerlink" title="会话层服务"></a>会话层服务</h4><ul><li>认证</li><li>权限</li><li>会话恢复</li></ul><h4 id="会话层协议"><a href="#会话层协议" class="headerlink" title="会话层协议"></a>会话层协议</h4><ul><li>PAP, 密码认证协议</li><li>PPTP, 点对点隧道协议</li><li>L2TP, 第二层隧道协议</li><li>RPC, 远程过程调用</li><li>SDP, 套接字直接协议</li></ul><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层向上对应用层服务，向下接受来自会话层的服务。表示层为在应用过程之间传送的信息提供表示方法的服务，它只关心信息发出的语法和语义</p><p>表示层从应用层接收数据。这些数据是以字符和数字的形式出现的，表示层将这些字符和数字转换成机器可理解的二进制格式。</p><p>为不同终端的上层用户提供数据和信息正确的语法表示变换方法。表示层确保数据以应用层可以理解的形式传递。处理数据编码、压缩和加密。</p><h4 id="表示层的主要功能"><a href="#表示层的主要功能" class="headerlink" title="表示层的主要功能"></a>表示层的主要功能</h4><ul><li>数据语法转换</li><li>语法表示</li><li>连接管理</li><li>数据处理</li><li>数据加密和解密</li><li>数据压缩和解压</li><li>数据编码和解码</li></ul><h4 id="表示层协议"><a href="#表示层协议" class="headerlink" title="表示层协议"></a>表示层协议</h4><ul><li>HTTP&#x2F;HTTPS</li><li>FTP&#x2F;FTPS</li><li>SSH</li><li>Telnet</li><li>ASN.1</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>最上面的一层 应用层。电脑手机使用的应用程序就是在应用层实现的。应用层不关心数据的传输</p><p>用层直接和应用程序接口结合，并提供常见的网络应用服务。应用层也向第六层表示层发出请求。</p><p>应用层直接向最终用户应用程序提供网络服务。</p><h4 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h4><ul><li>DHCP</li><li>DNS</li><li>FTP</li><li>POP3</li><li>http</li><li>ftp</li><li>smtp<br>简单来说 假如你在给你的异地女朋友发微信信息 微信这个app就是属于<strong>应用层</strong> 将你发的这个信息转化为机器<strong>能够懂的适合传输</strong>的形式 这个就是<strong>表示层</strong>的作用 这个信息要发给你的女朋友 你和女朋友的微信会创建一个<strong>会话连接</strong> 会话层会在信息发过去的时候<strong>保证传输</strong>顺利进行 传输层会把数据<strong>分成</strong>适合传输的<strong>数据包</strong>进行传输 网络层会规划一条<strong>合适的路径</strong>传输信息 数据链路层会通过物理网络将<strong>数据包传给</strong>物理层 物理层就能把数据包发送到接收方手机 就能接收到发送方的信息</li></ul><h2 id="tcp-ip模型"><a href="#tcp-ip模型" class="headerlink" title="tcp&#x2F;ip模型"></a>tcp&#x2F;ip模型</h2><ul><li>应用层</li><li>传输层</li><li>网络接口层</li><li>链路层</li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>一个是物理端口 一个是逻辑端口</p><p>物理端口是用于连接物理设备之间的接口，如ADSL Modem、集线器、交换机、路由器上用于连接其他网络设备的接口，如RJ-45端口、SC端口等等。</p><p>逻辑端口是指逻辑意义上用于区分服务的端口，比如用于浏览网页服务的80端口，用于FTP服务的21端口等。如TCP&#x2F;IP协议中的服务端口，通过不同的逻辑端口来区分不同的服务。</p><p>最多可以有65536个端口 。端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535 。</p><p>说白了 端口可以简单理解为门牌号 特定服务或者特定应用的门牌号 外界互联网来的消息，数据包可以通过端口到达指定的应用或者服务</p><h3 id="周知端口"><a href="#周知端口" class="headerlink" title="周知端口"></a>周知端口</h3><p>0-1023 周知端口</p><h3 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h3><p>1024-65535 动态端口</p><h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>由网络号和主机号组成</p><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>0.0.0.0用来寻找自己的ip</p><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><ul><li>A类 10.0.0.0 - 10.255.255.255 (10&#x2F;8)</li><li>B类 172.16.0.0 - 172.31.255.255 (172.16&#x2F;12)</li><li>C类 192.168.0.0 - 192.168.255.255 (192.168&#x2F;16)</li></ul><h2 id="dhcp协议"><a href="#dhcp协议" class="headerlink" title="dhcp协议"></a>dhcp协议</h2><p>动态主机配置协议 用于集中对用户IP地址进行动态管理和配置。</p><h3 id="DHCP遵循四个步骤：发现、提供、请求和确认-DORA-："><a href="#DHCP遵循四个步骤：发现、提供、请求和确认-DORA-：" class="headerlink" title="DHCP遵循四个步骤：发现、提供、请求和确认 (DORA)："></a>DHCP遵循四个步骤：发现、提供、请求和确认 (DORA)：</h3><ul><li>DHCP发现：客户端将广播 DHCPDISCOVER 消息，寻找本地DHCP服务器（如果存在）。</li><li>DHCP提供：服务器以 DHCPOFFER 消息进行响应，其中包含可供客户端接受的 IP 地址。</li><li>DHCP请求：客户端以 DHCPREQUEST 消息进行响应，表明它已接受提供的 IP。</li><li>DHCP确认：服务器以 DHCPACK 消息进行响应，以确认提供的 IP 地址现已分配给该客户端。</li></ul><h2 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h2><p>arp协议(地址解析协议) IP地址对mac地址的映射 询问IP地址对应的mac地址</p><p>目标 MAC 地址<br>源 MAC 地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> web 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bricks Heist 教程</title>
      <link href="/2025/01/25/Bricks-Heist-%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/25/Bricks-Heist-%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="祝师傅们2025越来越好-技术越来越牛"><a href="#祝师傅们2025越来越好-技术越来越牛" class="headerlink" title="祝师傅们2025越来越好 技术越来越牛"></a>祝师傅们2025越来越好 技术越来越牛</h3><h1 id="Bricks-Heist教程"><a href="#Bricks-Heist教程" class="headerlink" title="Bricks Heist教程"></a>Bricks Heist教程</h1><p>我们看一下Bricks Heist 这个简单挑战<br><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/title.png" alt="title"></p><p>这个是题目</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/ask.png" alt="title"></p><p>我们先把自己的机子ip和bricks.thm绑到&#x2F;etc&#x2F;hosts里面</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/hosts.png" alt="hosts"></p><p>连接上openvpn之后咱正式开搞</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>先nmap开扫 可以看到他们开放了22，80和443端口</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/nmap.png" alt="nmap"></p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/duankou.png" alt="nmap"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>我们在浏览器那搜索ip地址和域名 看一下有什么结果吗</p><p>直接输ip的话是啥也没有</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/ip.png" alt="ip"></p><p>我们换成域名试一试 发现成功了</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/brick.png" alt="brick"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>我们把这个拉到wpscan里面扫描一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url https://bricks.thm/ --disable-ssl-checks</span><br></pre></td></tr></table></figure><p>为什么要加–disable-ssl-checks这个参数捏 不加的话他会报错 说目标网站的 SSL&#x2F;TLS 证书不正确或无法验证</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/scan1.png" alt="scan"></p><p><strong>–disable-ssl-checks</strong> 参数可以让你在面对无效证书（如自签名证书、过期证书等）时继续进行扫描，跳过 SSL&#x2F;TLS 证书验证检查。</p><p>扫描结果我们可以发现在robots.txt中有两个可疑的路径</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/wpscan.png" alt="scan"></p><p>第二个呢 就是wordpess的主题 bricks和主题版本1.9.5</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/wpscan3.png" alt="scan"></p><p>结合这两个信息 咱可以在浏览器搜搜有什么漏洞吗 成功发现一个 把他的python下载到机子里面</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/ludong.png" alt="loudong"></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>我们跑一下这个文件 就可以获得这个网站的shell 然后查看题目需要的文件是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 CVE-2024-25600.py -u https://bricks.thm</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>-u</strong> &#x2F; –url：指定目标 URL。用于设置你要扫描的 Web 地址。</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/flag.png" alt="loudong"></p><p>刚进去就发现一个可疑文件 直接cat查看一下 发现第一问解出来了 flag到手</p><p>第二题看可疑进程和进程的服务名</p><p>我们先<strong>ps aux</strong>查看一下 但发现太多了 我们进一步筛选 查找一下正在运行中的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl | grep running</span><br></pre></td></tr></table></figure><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/jingcheng.png" alt="run"></p><p>我们在里面发现了一个可疑进程 然后systemctl查一下具体信息</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/jingcheng1.png" alt="run"></p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/jiingcheng3.png" alt="run"></p><p>就发现了可疑进程是nm-inet-dialog 服务名叫做ubuntu.service</p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>要看日志文件叫什么名字 在刚才的查询中发现这个服务在&#x2F;lib&#x2F;networkmanager的inet.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head /lib/networkmanager/inet.conf</span><br></pre></td></tr></table></figure><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/inet.png" alt="head"></p><p>发现id是个复杂的加密 把这串id复制到cyberchef中 这个id进行了十六进制转换 再来两次base64的转换</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/bitcoiin.png" alt="cyber"></p><p>得出来的结果分成一般就是我们需要的钱包地址</p><h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p>我们知道比特币地址之后 在<a href="http://www.blockchain.com中搜索一下地址/">www.blockchain.com中搜索一下地址</a> 查询一下他的交易流程 发现一个地址频繁出现 我们把这个地址复制 搜索一下 </p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/bit.png" alt="bit"></p><p>搜完之后 随便点了一个链接 得知是lockbit组织</p><p><img src="/images/Bricks-Heist-%E6%95%99%E7%A8%8B/lockbit.png" alt="bit"></p><p>这个练习挺好玩的 用到了wpscan nmap和反向提权 其实在python的那一步 反向提权一下会更方便一点 可能我不太熟练吧 就直接这么查找需要的东西了</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2025/01/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2025/01/25/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>信息收集的重要性毋庸置疑 古今中外 生活的每个部分都离不开信息收集 强大的信息收集能力是制胜关键。渗透测试也不例外 有句话说得好 渗透测试的本质就是信息收集 </p><p>信息收集通常分为</p><ul><li><p>域名信息收集</p></li><li><p>子域名信息收集</p></li><li><p>站点信息收集</p></li><li><p>旁站信息收集</p></li><li><p>c端主机查询</p></li><li><p>敏感信息收集</p></li><li><p>服务器信息收集</p></li><li><p>端口信息收集</p></li><li><p>真实IP地址识别</p></li><li><p>主动信息收集</p></li></ul><h2 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h2><p>域名信息收集<br><strong>域名</strong>（英语：Domain Name），又称<strong>网域</strong>，是由一串用<strong>点分隔</strong>的名字组成的Internet上某<strong>一台计算机</strong>或<strong>计算机组</strong>的名称，用于在数据传输时对计算机的<strong>定位标识</strong>（有时也指地理位置）。由于IP地址具有<strong>不方便记忆</strong>并且<strong>不能显示地址组织</strong>的<strong>名称</strong>和<strong>性质</strong>等缺点，人们设计出了域名，并通过dns(Domain Name System)网域名称系统来将域名和IP地址<strong>相互映射</strong>，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="顶级域名-一级域名："><a href="#顶级域名-一级域名：" class="headerlink" title="顶级域名&#x2F;一级域名："></a>顶级域名&#x2F;一级域名：</h4><p>顶级域（或顶级域名，也称为一级域名），是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。顶级域名是域名的最后一个部分，即是域名最后一点之后的字母，例如在<a href="http://www.example.com这个域名中,顶级域是.com./">http://www.example.com这个域名中，顶级域是.com。</a></p><h4 id="二级域名："><a href="#二级域名：" class="headerlink" title="二级域名："></a>二级域名：</h4><p>除了顶级域名，还有二级域名，就是最靠近顶级域名左侧的字段。例如在<a href="http://www.example.com这个域名中,example就是二级域名./">http://www.example.com这个域名中，example就是二级域名。</a></p><h4 id="子域名："><a href="#子域名：" class="headerlink" title="子域名："></a>子域名：</h4><p>子域名，在域名系统等级中，属于更高一层域的域。比如，mail.example.com和calendar.example.com是example.com的两个子域，而example.com则是顶级域.com的子域。凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少分为二级子域名，三级子域名以及多级子域名。</p><p>为什么要收集子域名</p><p>子域名枚举可以在<strong>测试范围</strong>内发现更多的<strong>域</strong>或<strong>子域</strong>，这将<strong>增大</strong>漏洞发现的<strong>几率</strong>。</p><p>有些<strong>隐藏的</strong>、<strong>被忽略</strong>的<strong>子域</strong>上运行的应用程序可能帮助我们发现<strong>重大漏洞</strong>。</p><p>在同一个组织的不同域或应用程序中往往存在相同的漏洞</p><p>假设我们的目标网络规模比较大，直接从主域入手显然是很不理智的，因为对于这种规模的目标，一般其<strong>主域</strong>都是<strong>重点防护区域</strong>，所以不如<strong>先进入目标的某个子域</strong>，然后再想办法迂回接近真正的目标，这无疑是个比较好的选择。</p><h5 id="利用在线工具查询"><a href="#利用在线工具查询" class="headerlink" title="利用在线工具查询"></a>利用在线工具查询</h5><p>网上有很多子域名的查询站点，可通过它们检索某个给定域名的子域名。如：</p><ul><li>DNSdumpster：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br></li><li>whois反查：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a><br></li><li>virustotal：<a href="http://www.virustotal.com/">www.virustotal.com</a><br></li><li>子域名爆破：<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br></li><li>IP反查绑定域名：<a href="http://dns.aizhan.com/">http://dns.aizhan.com/</a><br> </li><li><a href="https://hackertarget.com/">https://hackertarget.com/</a><br> </li><li>find-dns-host-records&#x2F;<br></li><li><a href="https://site.ip138.com/">https://site.ip138.com</a></li></ul><h5 id="通过证书透明度公开日志枚举子域名"><a href="#通过证书透明度公开日志枚举子域名" class="headerlink" title="通过证书透明度公开日志枚举子域名"></a>通过证书透明度公开日志枚举子域名</h5><p>证书透明度是证书授权机构的一个项目，证书授权机构会将每个SSL&#x2F;TLS证书发布到公共日志中。一个SSL&#x2F;TLS证书通常包含域名、子域名和邮件地址，这些也经常成为攻击者非常希望获得的有用信息。</p><p>查找某个域名所属证书的最简单的方法就是使用搜索引擎来搜索一些公开的CT日志，例如以下网站：</p><p>crt.sh：<a href="https://crt.sh/">https://crt.sh</a><br>censys：<a href="https://censys.io/">https://censys.io</a></p><h5 id="子域名信息收集-聚合工具"><a href="#子域名信息收集-聚合工具" class="headerlink" title="子域名信息收集-聚合工具"></a>子域名信息收集-聚合工具</h5><p>聚合工具就是，结合和爆破，证书，搜索引擎，DNS解析记录等多个方式去探测子域名比如：oneforall</p><p>OneForAll(是一款集百家之长，功能强大的全面快速子域收集终极神器)</p><h6 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h6><p>oneforall<br>下载好OneForAll，进入到OneForAll的目录下，执行以下命令安装OneForAll所需的环境依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install -U pip setuptools wheel -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/oneforall.png" alt="oneforall"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/oneforall.png2" alt="oneforall"></p><p>subDomainBrute</p><p>subDomainsBrute是一款高并发的DNS暴力枚举工具</p><p>下载完之后 进入目录安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install dnspython gevent</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/submain.png" alt="sub"></p><h5 id="kali的工具"><a href="#kali的工具" class="headerlink" title="kali的工具"></a>kali的工具</h5><p>在kali中的信息收集模块的DNS分析中，有很多工具可以进行域名信息收集</p><ul><li>Dnsenum：域名信息收集</li><li>Dnsmap：收集信息和枚举DNS信息</li><li>Dnsrecon：用于DNS侦察</li><li>Fierce ：子域名查询</li></ul><h5 id="windows的工具"><a href="#windows的工具" class="headerlink" title="windows的工具"></a>windows的工具</h5><p>Windows上的子域名查询工具主要由：</p><p>Layer子域名挖掘机<br>subDomainsbrute<br>K8<br>Sublist3r<br>Maltego</p><h3 id="Whois-查询"><a href="#Whois-查询" class="headerlink" title="Whois 查询"></a>Whois 查询</h3><p>whois 是用来查询域名的<strong>IP</strong>以及<strong>所有者</strong>等信息的传输协议。简单说，whois就是一个用来<strong>查询域名</strong>是否已经被注册，以及<strong>注册域名</strong>的<strong>详细信息</strong>的<strong>数据库</strong>（如域名所有人、域名注册商），不同域名后缀的Whois信息需要到<strong>不同</strong>的Whois数据库查询。通过whois来实现对域名信息的查询，可以得到注册人的<strong>姓名</strong>和邮<strong>箱信息</strong>通常对测试个人站点非常有用，因为我们可以通过搜索引擎和社交网络挖掘出域名所有人的很多信息。</p><h4 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h4><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a></p><p><a href="https://mwhois.chinaz.com/">https://mwhois.chinaz.com/</a>  </p><p><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p><p><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a></p><p><a href="https://whois.cnnic.cn/WelcomeServlet">https://whois.cnnic.cn/WelcomeServlet</a></p><h4 id="域名反查："><a href="#域名反查：" class="headerlink" title="域名反查："></a>域名反查：</h4><p><a href="https://mwhois.chinaz.com/">https://mwhois.chinaz.com/</a></p><p><a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a></p><h4 id="icp备案查询："><a href="#icp备案查询：" class="headerlink" title="icp备案查询："></a>icp备案查询：</h4><p><a href="https://beian.mlit.gov.cn/">https://beian.mlit.gov.cn/</a></p><p><a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p><p><a href="https://beian88.com/">https://beian88.com/</a></p><h4 id="在线查询"><a href="#在线查询" class="headerlink" title="在线查询"></a>在线查询</h4><p>如今网上出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名&#x2F;IP的whois信息由对应的管理机构保存。</p><p>常见的网站包括：</p><ul><li><p>Whois站长之家查询：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p></li><li><p>阿里云中国万网查询：<a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a></p></li><li><p>Whois Lookup 查找目标网站所有者的信息：<a href="http://whois.domaintools.com/">http://whois.domaintools.com/</a></p></li><li><p>Netcraft Site Report 显示目标网站上使用的技术：<a href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a></p></li><li><p>Robtex DNS 查询显示关于目标网站的全面的DNS信息：<a href="https://www.robtex.com/">https://www.robtex.com/</a></p></li><li><p>全球Whois查询：<a href="https://www.whois365.com/cn/">https://www.whois365.com/cn/</a></p></li><li><p>站长工具爱站查询：<a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p></li></ul><p>还可以在Kali Linux下自带的Whois查询工具，通过命令Whois查询域名信息，只需输入要查询的域名即可</p><h4 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h4><p><strong>网站备案信息</strong>是根据<strong>国家法律法规规定</strong>，由<strong>网站所有者</strong>向国家<strong>有关部门</strong>申请的<strong>备案</strong>，是国家信息产业部对网站的一种管理途径，是为了防止在网上从事非法网站经营活动，当然主要是针对国内网站。</p><p>在备案查询中我们主要关注的是：单位信息例如<strong>名称</strong>、<strong>备案编号</strong>、<strong>网站负责人</strong>、<strong>法人</strong>、<strong>电子邮箱</strong>、<strong>联系电话</strong>等。</p><p>常用的备案信息查询网站有以下几个：</p><p>ICP&#x2F;IP地址&#x2F;域名信息备案管理系统：<a href="http://beian.miit.gov.cn/publish/query/indexFirst.action">http://beian.miit.gov.cn/publish/query/indexFirst.action</a></p><p>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a></p><p>备案吧吧：<a href="https://www.beian88.com/">https://www.beian88.com/</a></p><p>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p><h2 id="站点信息收集"><a href="#站点信息收集" class="headerlink" title="站点信息收集"></a>站点信息收集</h2><p>接下来进行web网站站点信息收集，主要收集如下信息：</p><ul><li>CMS指纹识别</li><li>历史漏洞</li><li>脚本语言</li><li>敏感目录&#x2F;文件</li><li>Waf识别</li></ul><h3 id="CMS指纹识别"><a href="#CMS指纹识别" class="headerlink" title="CMS指纹识别"></a>CMS指纹识别</h3><p><strong>CMS</strong>（<strong>内容管理系统</strong>）又称为<strong>整站系统</strong>或<strong>文章系统</strong>，用于<strong>网站内容管理</strong>。用户只需要下载对应的CMS软件包，就能<strong>部署搭建</strong>，并<strong>直接利用</strong>CMS。但是各种CMS都具有其<strong>独特的结构命名规则</strong>和<strong>特定的文件内容</strong>，因此可以利用这些内容来获取<strong>CMS站点</strong>的<strong>具体软件CMS</strong>与<strong>版本</strong>。</p><p>指纹识别指的是通过关键特征，识别出目标的CMS系统、服务 器、开发语言、操作系统、CDN、WAF的类别版本等等</p><p>在渗透测试中，对进行指纹识别是相当有必要的，识别出相应的CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。</p><p>常见的CMS有Dedecms(织梦)、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。</p><p>（1）在线识别</p><p>如今，网上一些在线的网站查询CMS指纹识别，如下所示：</p><ul><li>云悉：<a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a></li><li>BugScaner: <a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></li><li>潮汐指纹：<a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></li><li>云悉指纹: <a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a></li></ul><p>（2）利用工具</p><p>常见的CMS指纹识别工具有<strong>WhatWeb</strong>、<strong>WebRobo</strong>、<strong>椰树</strong>、<strong>御剑Web指纹识别</strong>。大禹CMS识别程序等，可以快速识别一些主流CMS。</p><p>当我们得知了一个站点的cms类型后，我们可以在网上查找与其相关的漏洞并进行相应的测试。</p><p>（3）手工识别</p><ol><li>根据HTTP响应头判断，重点关注<strong>X-Powered-By</strong>、<strong>cookie</strong>等字段</li><li>根据HTML 特征，重点关注 <strong>body</strong>、<strong>title</strong>、<strong>meta</strong>等标签的内容和属性。</li><li>根据特殊的t<strong>class</strong>判断。HTML 中存在特定 class 属性的某些 <strong>div 标签</strong>，如<body class="ke-content"></body></li></ol><h3 id="敏感目录-文件收集"><a href="#敏感目录-文件收集" class="headerlink" title="敏感目录&#x2F;文件收集"></a>敏感目录&#x2F;文件收集</h3><p>也就是对<strong>目标网站</strong>做个<strong>目录扫描</strong>。在web渗透中，探测Web目录结构和隐藏的敏感文件是一个十分重要的环节，从中可以获取网站的<strong>后台管理页面</strong>、<strong>文件上传界面</strong>、<strong>robots.txt</strong>，甚至可能扫描出<strong>备份文件</strong>从而得到网站的<strong>源代码</strong>。</p><p>目录扫描可以让我们发现这个网站存在<strong>多少个目录</strong>，多少个<strong>页面</strong>，探索出网站的<strong>整体结构</strong>。通过目录扫描我们还能扫描<strong>敏感文件</strong>，<strong>后台文件</strong>，<strong>数据库文件</strong>，和<strong>信息泄漏文件</strong>等等</p><h4 id="常见目录泄露"><a href="#常见目录泄露" class="headerlink" title="常见目录泄露"></a>常见目录泄露</h4><p><strong>目录遍历漏洞</strong>(程序在实现上没有<strong>充分过滤</strong>用户输入的..&#x2F;之类的<strong>目录跳转符</strong>，导致恶意用户可以通过提交目录跳转来遍历服务器上的任意文件。)</p><p>robots.txt          允许爬虫爬取的页面</p><p>sitemap.xml     指导搜索引擎搜索哪些页面 列出了网站的所有重要页面，帮助搜索引擎更好地索引网页。</p><p>网站的备份文件 &#x2F; 数据</p><p>后台登录的目录： &#x2F;admin， &#x2F;manage</p><p>安装包（源码）列如：1.zip，非开源，商用</p><p>上传的目录： 文件上传漏洞，  &#x2F;upload，&#x2F;upload.php</p><p>php探针(是用来监控服务器的工具，它可以显示服务器的运行状况，如硬盘使用、内存占用、网络流量、系统负载和当前时间等信息。)： phpinfo(，用于显示 PHP 配置和系统信息)，</p><p>文本编辑器： kindeditor，CKeditor ， Ueditor，文件上传漏洞、命令注入(如果没有严格的验证和清理，攻击者可能利用这些编辑器进行文件上传攻击、命令注入或跨站脚本攻击（XSS）)</p><h4 id="常见的网站目录的扫描工具主要有："><a href="#常见的网站目录的扫描工具主要有：" class="headerlink" title="常见的网站目录的扫描工具主要有："></a>常见的网站目录的扫描工具主要有：</h4><ul><li>御剑后台扫描工具</li><li>dirbuster扫描工具</li><li>dirsearch扫描工具</li><li>dirb</li><li>wwwscan</li><li>Sensitivefilescan</li></ul><h3 id="Waf识别"><a href="#Waf识别" class="headerlink" title="Waf识别"></a>Waf识别</h3><p><strong>Web应用防护系统</strong>（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对<strong>HTTP&#x2F;HTTPS</strong>的安全策略来专门为Web应用提供保护的一款产品。</p><h4 id="waf介绍"><a href="#waf介绍" class="headerlink" title="waf介绍"></a>waf介绍</h4><p>WAF分为<strong>非嵌入型WAF和嵌入型WAF</strong>，非嵌入型WAF指的是<strong>硬件型WAF</strong>、<strong>云WAF</strong>、<strong>软件型WAF</strong>之类的；而嵌入型WAF指的是网站<strong>内置的WAF</strong></p><p>非嵌入型WAF对Web流量的解析完全是<strong>靠自身</strong>，而嵌入型WAF拿到的Web数据是<strong>已经被解析加工好的</strong>。所以非嵌入型的受攻击机面还涉及到其他层面，</p><p>而嵌入型WAF从Web容器模块型WAF、代码层WAF往下走，其对抗畸形报文、扫操作绕过的能力越来越强。</p><h4 id="wafoof"><a href="#wafoof" class="headerlink" title="wafoof"></a>wafoof</h4><p><strong>wafw00f</strong>是一个Web应用防火墙（WAF）指纹识别的工具。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>下载完之后 进入目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><h4 id="wafw00f的工作原理："><a href="#wafw00f的工作原理：" class="headerlink" title="wafw00f的工作原理："></a>wafw00f的工作原理：</h4><ol><li><p>发送<strong>正常</strong>的<strong>HTTP请求</strong>，然后<strong>分析响应</strong>，这可以识别出很多WAF。</p></li><li><p>如果不成功，它会发送一些（可能是恶意的）HTTP请求，使用简单的<strong>逻辑推断</strong>是哪一个WAF。</p></li><li><p>如果这也不成功，它会分析之前返回的响应，使用<strong>其它简单的算法猜测</strong>是否有某个WAF或者安全解决方案响应了我们的攻击。</p></li></ol><h3 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h3><p>有时候，针对某些安全做得很好的目标，直接通过技术层面是无法完成渗透测试的。此时，便可以利用<strong>搜索引擎搜索</strong>目标<strong>暴露在互联网上</strong>的<strong>关联信息</strong>。例如：<strong>数据库文件</strong>、<strong>SQL注入</strong>、<strong>服务配置信息</strong>，甚至是通过Git找到<strong>站点</strong>泄露源代码，以及<strong>Redis</strong>等未授权访问、<strong>Robots.txt</strong>等敏感信息，从而达到渗透目的。</p><p>Google hacking</p><ul><li><strong>intext</strong>：寻找正文中含有关键字的网页</li><li><strong>intitle</strong>：寻找标题中含有关键字的网页</li><li><strong>allintitle</strong>：用法和intitle类似，只不过可以指定多个词</li><li><strong>inurl</strong>：搜索url中含有关键词的网页</li><li><strong>allinurl</strong>：用法和inurl类似，只不过可以指定多个词</li><li><strong>site</strong>：指定访问的站点</li><li><strong>filetype</strong>：指定访问的文件类型</li><li><strong>link</strong>：指定链接的网页</li><li><strong>related</strong>：搜索相似类型的网页</li><li><strong>info</strong>：返回站点的指定信息，例如：info:<a href="http://www.baidu.-/">www.baidu.-</a> com   将返回百度的一些信息</li><li><strong>phonebook</strong>：电话簿查询美国街道地址和电话号码信息</li><li><strong>Index of</strong>：利用 Index of 语法可以发现允许目录浏览的web网站，就像在本地的普通目录一样</li></ul><h3 id="Github信息泄露"><a href="#Github信息泄露" class="headerlink" title="Github信息泄露"></a>Github信息泄露</h3><p>itHub作为开源代码平台，给程序员提供了很多便利，但如果使用不当，比如将包含了账号密码、密钥等配置文件的代码上传了，导致攻击者能发现并进一步利用这些泄露的信息，就是一个典型的GitHub敏感信息泄露漏洞，再如开发人员在开发时，常常会先把源码提交到github，最后再从远程托管网站把源码pull到服务器的web目录下，如果忘记把.git文件删除，就造成此漏洞。利用.git文件恢复网站的源码，而源码里可能会有数据库的信息，</p><h2 id="旁站信息收集"><a href="#旁站信息收集" class="headerlink" title="旁站信息收集"></a>旁站信息收集</h2><p>旁站是与攻击目标在同一服务器上的不同网站,在攻击目标没有漏洞的情况 下,可以通过查找旁站的漏洞攻击旁站,然后再通过提权拿到服务器的最高权限,拿到服务器的最高权限后攻击目标也就拿下了</p><h3 id="查询旁站的方式"><a href="#查询旁站的方式" class="headerlink" title="查询旁站的方式"></a>查询旁站的方式</h3><p>获取旁站一般有这个几个方式：</p><ol><li>通过站长工具进行同IP的查询</li></ol><p><a href="https://stool.chinaz.com/same">https://stool.chinaz.com/same</a></p><p><a href="https://chapangzhan.com/">https://chapangzhan.com/</a></p><p><a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p><ol start="2"><li><p>搜索引擎搜索</p></li><li><p>网络空间探测引擎搜索</p></li></ol><h2 id="c端主机查询"><a href="#c端主机查询" class="headerlink" title="c端主机查询"></a>c端主机查询</h2><p>C段查询主要是当前的IP攻击不下来的时候，可以攻击他的C段，比如IP是220.181.34.34是我们的目标，但是攻击不下来，可以去扫描220.181.34.0-255这个网段，看看能不能攻击下来</p><p>对于单独网站的渗透测试，C段扫描意义不大。C段指的是同一内网段内的其他服务器</p><h3 id="nmap扫描c端主机"><a href="#nmap扫描c端主机" class="headerlink" title="nmap扫描c端主机"></a>nmap扫描c端主机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn -ip/24</span><br></pre></td></tr></table></figure><h3 id="搜索引擎C段信息"><a href="#搜索引擎C段信息" class="headerlink" title="搜索引擎C段信息"></a>搜索引擎C段信息</h3><p>使用google或者百度进行语法搜索 site:x.x.x.*进行C段的探测</p><h3 id="c端扫描的工具扫描"><a href="#c端扫描的工具扫描" class="headerlink" title="c端扫描的工具扫描"></a>c端扫描的工具扫描</h3><h3 id="使用网络空间探测引擎-IP-”XXX-XXX-XXX-0-24”"><a href="#使用网络空间探测引擎-IP-”XXX-XXX-XXX-0-24”" class="headerlink" title="使用网络空间探测引擎 IP&#x3D;”XXX.XXX.XXX.0&#x2F;24”"></a>使用网络空间探测引擎 IP&#x3D;”XXX.XXX.XXX.0&#x2F;24”</h3><h3 id="存活资产探测"><a href="#存活资产探测" class="headerlink" title="存活资产探测"></a>存活资产探测</h3><p>C段+全段口会生成很多资产，但是其中会有不能访问的，所以我们需要资产探活。</p><p>用EHole工具</p><h2 id="服务器信息收集"><a href="#服务器信息收集" class="headerlink" title="服务器信息收集"></a>服务器信息收集</h2><p>我们还需要对目标服务器的信息进行收集，主要包括一下部分：</p><ul><li>Web服务器指纹识别</li><li>真实IP地址识别</li><li>编程语言</li><li>Web中间件</li><li>端口信息收集</li><li>后端存储技术识别</li></ul><p>Web服务器指纹识别<br>Web服务器指纹识别是了解正在运行的web服务器类型和版本，目前市场上存在几种不同的web服务器提供商和软件版本，了解被测试的web服务器的类型，能让测试者更好去测试已知漏洞和大概的利用方法，将会在渗透测试过程中有很大的帮助，甚至会改变测试的路线。</p><h3 id="Web服务器指纹识别主要识别一下信息："><a href="#Web服务器指纹识别主要识别一下信息：" class="headerlink" title="Web服务器指纹识别主要识别一下信息："></a>Web服务器指纹识别主要识别一下信息：</h3><p>1、Web服务器<strong>名称</strong>，<strong>版本</strong></p><p>2、Web服务器<strong>后端</strong>是否有<strong>应用服务器</strong></p><p>3、<strong>数据库</strong>(DBMS)是否**部署在同一主机(host)**，数据库类型</p><p>4、Web应用使用的<strong>编程语言</strong></p><p>5、Web<strong>应用框架</strong></p><h4 id="手工检测"><a href="#手工检测" class="headerlink" title="手工检测"></a>手工检测</h4><ol><li><p>HTTP头分析<br>即查看HTTP响应头中的<strong>Server</strong>、<strong>X-Powered-By</strong>、<strong>Cookie</strong> 等字段，这也是最基本的方法。</p></li><li><ol start="2"><li>协议行为<br>即从<strong>HTTP头字段顺序分析</strong>，观察HTTP响应头的<strong>组织顺序</strong>，因为每个服务器都有一个内部的H<strong>TTP头排序</strong>方法。</li></ol></li><li><p>浏览并观察网站<br>我们可以观察网站某些位置的<strong>HTML源码</strong>(<strong>特殊的class名称</strong>)及其<strong>注释(comment)部分</strong>，可能暴露有价值信息。观察<strong>网站页面后缀</strong>可以判断Web应用使用的编程语言和框架。</p></li><li><p>刻意构造错误<br>错误页面可以给你提供关于服务器的大量信息。可以通过构造含有随机字符串的URL，并访问它来尝试得到404页面。</p></li></ol><h4 id="利用工具识别"><a href="#利用工具识别" class="headerlink" title="利用工具识别"></a>利用工具识别</h4><p><strong>whatweb</strong>是一款用于辅助的自动化Web应用指纹分析工具</p><h2 id="真实IP地址识别"><a href="#真实IP地址识别" class="headerlink" title="真实IP地址识别"></a>真实IP地址识别</h2><p>我们平时使用浏览器，使用的都是<strong>域名</strong>，域名的存在是为了方便人的记忆，其实浏览器本质还是<strong>访问真实IP地址</strong>来获取页面的。</p><p>在渗透测试中，一般只会给你一个域名，那么我们就要根据这个域名来确定目标服务器的真实IP，我们可以通过像<a href="http://www.ip138.com这样的ip查询网直接获取目标的一些ip及域名信息,但这里的前提是目标服务器**没有使用cdn/">www.ip138.com这样的IP查询网直接获取目标的一些IP及域名信息，但这里的前提是目标服务器**没有使用CDN</a>**</p><p>找到真实的IP我们就可以访问这个IP的C段和端口，方便进一步渗透，</p><h3 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h3><p>CDN的全称是Content Delivery Network，即<strong>内容分发网络</strong>。企业利用分布在<strong>不同区域</strong>的<strong>节点服务器群组</strong>成流量分配<strong>管理平台</strong>，为用户提供内容<strong>分散存储</strong>和<strong>高速缓存服务</strong></p><h3 id="CDN的优势"><a href="#CDN的优势" class="headerlink" title="CDN的优势"></a>CDN的优势</h3><ol><li><p>提高用户访问速率，优化用户使用体验</p></li><li><p>隐藏真实服务器的IP</p></li><li><p>提供WAF功能，目前很多CDN也提供了WAF的功能，我们的访问请求会先经过CDN节点的过滤，该过滤可对SQL注入、XSS、Webshell上传、命令注入、恶意扫描等攻击行为进行有效检测和拦截。CDN节点将认为无害的数据提交给真实的主机服务器。</p></li></ol><h3 id="CDN几种访问方式的不同"><a href="#CDN几种访问方式的不同" class="headerlink" title="CDN几种访问方式的不同"></a>CDN几种访问方式的不同</h3><ol><li>传统访问：用户访问域名–&gt;解析服务器IP–&gt;访问目标主机</li><li>普通CDN：用户访问域名–&gt;CDN节点–&gt;真实服务器IP–&gt;访问目标主机</li><li>带WAF的CDN：用户访问域名–&gt;CDN节点（云WAF）–&gt;真实服务器IP–&gt;访问目标主机</li></ol><p>我们也可以<strong>设置代理</strong>或者通过在线ping网站来在不同地区进行ping测试，然后对比每个地区ping出的IP结果，查看这些IP是否一致，<strong>一致</strong>，则极有可能<strong>不存在CDN</strong>。根据 CDN 的工作原理，如果网站使用了 CDN，那么从<strong>全国各地访问网站</strong>的 IP 地址是<strong>各个 CDN 节点的 IP 地址</strong>，那么如果ping出来的IP<strong>大多不太一样</strong>或者<strong>规律性很强</strong>，可以尝试查询这些IP的归属地，判断是否存在CDN。有以下网站可以进行ping测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://ping.chinaz.com/</span><br><span class="line">https://www.wepcc.com</span><br><span class="line">https://www.17ce.com</span><br></pre></td></tr></table></figure><p>SearchMap判断目标有没有使用CDN</p><p>searchmap是一款集域名解析、IP反查域名、WHOIS查询、CDN检测、端口扫描、目录扫描、子域名挖掘为一体的前渗透测试综合信息收集工具</p><h3 id="如何绕过CDN找到目标真实IP？"><a href="#如何绕过CDN找到目标真实IP？" class="headerlink" title="如何绕过CDN找到目标真实IP？"></a>如何绕过CDN找到目标真实IP？</h3><ol><li><p>利用子域名。一般来说很多站长可能只会对主站或者流量较大的分站使用CDN，但是一些流量比较小的分站可能没有挂CDN，这些分站和主站虽然不是同一个IP但是都在同一个C段下面的情况，所以我们可以通过ping二级域名获取分站lP，从而能判断出目标的真实IP段。</p><br></li><li><p>查询主域。以前用CDN的时候有个习惯，只让WWW域名使用cdn，秃域名不使用，为的是在维护网站时更方便，不用等cdn缓存。所以试着把目标网站的www去掉，ping一下看ip是不是变了</p><br></li><li><p>扫描网站敏感文件，如phpinfo.php等，从而找到目标的真实IP。</p><br></li><li><p>从国外访问。国内很多CDN厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实P。我们可以通过国外在线代理网站访问，可能会得到真实的IP地址，</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://host-tracker.com/</span><br><span class="line"></span><br><span class="line">http://www.webpagetest.org/</span><br><span class="line"></span><br><span class="line">https://asm.ca.com/en/ping.php</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看域名历史解析记录。也许目标很久之前没有使用CDN，所以可能会存在使用 CDN 前的记录。所以可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://dnsdb.io/zh-cn/</span><br><span class="line"></span><br><span class="line"> https://x.threatbook.cn</span><br><span class="line"></span><br><span class="line"> https://viewdns.info/iphistory/</span><br><span class="line"></span><br><span class="line"> https://site.ip138.com/</span><br><span class="line"> </span><br><span class="line"> https://www.netcraft.com</span><br><span class="line"></span><br><span class="line"> https://viewdns.info/</span><br></pre></td></tr></table></figure><p>等网站来观察域名的IP历史记录。</p></li><li><p>Nslookup查询。查询域名的NS记录、MX记录、TXT记录等很有可能指向的是真实ip或同C段服务器。</p></li><li><p>利用网络空间搜索引擎。这里主要是利用网站返回的内容寻找真实原始IP，如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。最常见的网络空间搜索引擎有如下：</p></li></ol><ul><li>Shodan：<a href="https://www.shodan.io/">https://www.shodan.io/</a></li><li>钟馗之眼：<a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></li><li>FOFA：<a href="https://fofa.so/">https://fofa.so/</a></li></ul><ol start="8"><li>利用网站漏洞。比如有代码执行漏洞、SSRF、存储型的XSS都可以让服务器主动访问我们预设的web服务器，那么就能在日志里面看见目标网站服务器的真实IP。</li></ol><h2 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h2><p>查看本机端口</p><p>netstat命令</p><ol><li><p>nmap工具加Zenmap工具加Masscan工具扫描<br>zenmap是nmap的图形化界面<br>masscan高速端口扫描工具</p></li><li><p>由于使用工具通常会在目标网站留下痕迹，接下来提供一种在线网站探测方法。</p></li></ol><ul><li>在线网站：<a href="http://tool.chinaz.com/port/">http://tool.chinaz.com/port/</a></li><li>ThreatScan在线网站（网站基础信息收集）：<a href="https://scan.top15.cn/">https://scan.top15.cn/</a></li><li>Shodan：<a href="https://www.shodan.io/">https://www.shodan.io/</a></li></ul><h2 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h2><p>主动信息收集通常是在被动信息收集之后分析出重要攻击⾯或者⽬标重要信息的时候再针对性地去做主动信息收集，</p><p>在主动信息收集的时候通常持续时间⽐较⻓⽽且会通过各种不同的⽅式与⽬标交互。实战中最常⽤的⼿段是模拟或者伪装正常的业务流程与⽬标交互。</p><p>主动信息搜集之前我们一定要挂上代理，一方面是为了隐藏自己，一方面是为了防止测试的时候被封ip导致无法进行继续的渗透活动。</p><h3 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h3><p>Windows的TTL的值是128，而Linux的TTL大多是64。（默认情况下）</p><h3 id="服务版本识别"><a href="#服务版本识别" class="headerlink" title="服务版本识别"></a>服务版本识别</h3><p>流量包中的关键字</p><p>servers-db（nmap所维护的一个数据库，其中包含了各种网络服务的版本信息的特征数据，通过对目标服务发起请求，从响应中提取特征数据跟数据库中进行比对，就能识别出对应的版本）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_64177395/article/details/141267567">https://blog.csdn.net/qq_64177395/article/details/141267567</a></p><p><a href="https://www.cnblogs.com/0daybug/p/13800776.html">https://www.cnblogs.com/0daybug/p/13800776.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信息搜集之搜索</title>
      <link href="/2025/01/23/tryhackme%E7%9A%84%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
      <url>/2025/01/23/tryhackme%E7%9A%84%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="search-skill"><a href="#search-skill" class="headerlink" title="search skill"></a>search skill</h1><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p>评估信息时需要考虑的几点：</p><p>1.来源：确定发布信息的作者或组织。考虑他们是否在该主题上享有声誉和权威。发表博客文章并不代表某人在该主题上具有权威性。<br>2.证据和推理：检查主张是否有可靠的证据和逻辑推理。我们寻求确凿的事实和有力的论据。<br>3.客观性和偏见性：评估信息是否公正合理地呈现，是否反映了多种观点。我们不关心作者推动阴暗议程，无论是为了推销产品还是攻击竞争对手。<br>4.确证和一致性：通过多个独立来源的确证来验证所呈现的信息。检查多个可靠且信誉良好的来源是否同意核心主张。</p><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-23%20090909.png" alt="task"><br>答案</p><p>snake oli</p><p>ss</p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p>第三部分其实讲的是搜索引擎 介绍了些搜索运算符 我补充点 </p><h3 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h3><p>“精确匹配”<br>使用双引号可以搜索与引号中的关键字或短语完全匹配的内容。例如：<br>“数字营销策略”：仅返回包含该完整短语的页面。</p><p>AND（逻辑与）<br>在两个搜索词之间使用 AND，可以确保结果中同时包含这两个词。例如：<br>SEO AND 优化：返回同时包含“SEO”和“优化”的页面。</p><p>OR（逻辑或）<br>使用 OR 或竖线 | 可以搜索包含其中一个或多个词的结果。例如：<br>SEO OR “搜索引擎优化”：返回包含“SEO”或“搜索引擎优化”的页面。</p><p>-（排除）<br>在搜索词前加 - 可以排除特定词。例如：<br>SEO -营销：返回包含“SEO”但不包含“营销”的页面。</p><p>*（通配符）<br>使用 * 可以匹配任意单词或短语。例如：<br>数字 * 策略：返回包含“数字”和“策略”之间任意单词的页面。</p><h3 id="高级搜索运算符"><a href="#高级搜索运算符" class="headerlink" title="高级搜索运算符"></a>高级搜索运算符</h3><p>site:<br>限制搜索结果来自特定网站。例如：<br>site:example.com SEO：仅在 example.com 网站内搜索包含“SEO”的页面。</p><p>intitle:<br>查找标题中包含特定词的页面。例如：<br>intitle:SEO：返回标题中包含“SEO”的页面。</p><p>inurl:<br>查找 URL 中包含特定词的页面。例如：<br>inurl:SEO：返回 URL 中包含“SEO”的页面。</p><p>filetype:<br>搜索特定文件类型的文档。例如：<br>filetype:pdf SEO：返回包含“SEO”的 PDF 文件。</p><p>related:<br>查找与某个网站相关的其他网站。例如：<br>related:example.com：返回与 example.com 相关的网站。</p><p>allintitle:<br>查找标题中包含所有指定词的页面。例如：<br>allintitle:SEO 策略：返回标题中同时包含“SEO”和“策略”的页面。</p><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2/task3.png" alt="task3"></p><p>第一题 我们就可以这么搜 filetype:pdf cyber warfare report</p><p>第二题 ss(socket statistics)</p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p>接下来轮到专业搜索引擎 信息收集主要也是靠这些<br>比如说shodan </p><p>Virus Total是一个在线网站，使用多种防病毒引擎提供文件病毒扫描服务。它允许用户上传文件或提供 URL，以便通过单一操作使用多种防病毒引擎和网站扫描程序对其进行扫描。他们甚至可以输入文件哈希来检查之前上传的文件的结果。</p><p>ensys 专注于与互联网连接的主机、网站、证书和其他互联网资产。    </p><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2/task4.png" alt="task4"></p><p>我们在shodan中搜lghttpd就可以知道是us</p><p>第二天我们把hash值粘贴进Virus Total就能知道是啥</p><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p>漏洞 可以到cnnvd国家信息安全漏洞库 cnvd 国家信息安全漏洞共享平台里面查看</p><p>exploit-db 漏洞数据库列出了来自不同作者的漏洞代码；其中一些漏洞代码已经过测试并标记为已验证</p><p>还有nist可以去康康</p><p>题目<br><img src="/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2/task5.png"></p><p>我们可以在nist里面搜一下这个编号 看描述知道是来自xz的</p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p>技术文档 有时候东西解不出来 是去看看官方的文档 往往在里面就有解决方案或者一些一下灵感</p><p><img src="/source/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2/task6.png" alt="task6"></p><h2 id="task-7"><a href="#task-7" class="headerlink" title="task 7"></a>task 7</h2><p>就是社交媒体 有点社工学的感觉了 从社交媒体的蛛丝马迹中寻找</p><p><img src="/source/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2/task7.png" alt="task7"></p><p>第一问这个东东叫领英 好像是这么翻译的 就是比较严肃点的社交媒体</p><p>第二问 Facebook就是日常风的社交媒体</p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息搜集 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传说中的命令行</title>
      <link href="/2025/01/21/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2025/01/21/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天咱来到传说中的命令行 话说命令行三分天下 其一是Windows的cmd 其二是Windows powershell 其三是linux的shell 这三个利器要是能全部掌握 那就是传说中的大佬</p><p>命令行比起图形化界面更快 更高效 也更大佬</p><p>这次就简单介绍一下如何使用命令行来：</p><ul><li>显示基本系统信息</li><li>检查并排除网络配置故障</li><li>管理文件和文件夹</li><li>检查正在运行的进程</li></ul><p>一如既往 先ssh连接一下机子 准备操作</p><h2 id="Windows命令行"><a href="#Windows命令行" class="headerlink" title="Windows命令行"></a>Windows命令行</h2><p> MS Windows 命令提示符是cmd.exe</p><h3 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h3><p> <img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/task1.png" alt="task1"></p><p> 这个不用说 就是cmd.exe</p><h3 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h3><p> 基本系统信息</p><p> <strong>set</strong>命令检查你的路径</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/set.png" alt="set"></p><p> <strong>ver</strong>命令查看操作系统的版本</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ver</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/ver.png" alt="ver"></p><p>热身结束 我们看看题</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/task2.png" alt="task"></p><p>第一题直接用<strong>ver</strong>命令能查出他的os版本</p><p>第二题用<strong>systeminfo</strong>命令来看他的hostname</p><h3 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h3><p> 网络故障排除</p><p> 顾名思义 <strong>ipconfig</strong>命令 或者后面加个&#x2F;all。</p><p> 我们还可以<strong>ping</strong> 域名 如 ping <a href="http://www.baidu.com/">www.baidu.com</a></p><p> 下一个是<strong>tracert</strong> 代表跟踪路由。该命令tracert target_name跟踪到达目标所经过的网络路由</p><p> <strong>nslook</strong><br> nslookup example.com 它查找主机或域并返回其 IP 地址</p><p> netstat<br>此命令显示当前网络连接和监听端口</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/task3.png" alt="task3"></p><p>第一题使用<strong>ipconfig &#x2F;all</strong>来查找</p><p>第二题 用<strong>netstat</strong>命令来查找 我们要在后面加个 <strong>-abno</strong> 然后找到3389端口那一行</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/ss89.png" alt="er"></p><p>第三题 在ipconfig那也可以顺便看到掩码是255.255.0.0</p><h3 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h3><p>文件与磁盘管理</p><p><strong>cd命令</strong> 这个和linux中的有异曲同工之妙  </p><p>不带参数的话就和linux的pwd一样 显示当前的路径</p><p><strong>dir</strong>是显示子目录的命令</p><p><strong>tree命令</strong>就和linux命令差不多</p><p>新建和删除文件就是mkdir和rmdir</p><p><strong>copy</strong>命令允许文件从一个位置复制到另一个位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy file1 file2</span><br></pre></td></tr></table></figure><p><strong>move</strong>命令 移动文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move file1 文件夹名</span><br></pre></td></tr></table></figure><p><strong>erase</strong>命令 删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erase 文件名    </span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/task4.png" alt="task4"></p><p>先cd ..退出到根目录</p><p>然后cd 进题目要求的目录</p><p>more一下txt文件就行</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/flag.png" alt="task4"></p><h3 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h3><p>任务管理<br><strong>tasklist</strong>命令和<strong>taskkill</strong>命令</p><p>废话不多说 我们看看题</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/task5.png" alt="task5"></p><p>这题就是看你的熟悉程度 </p><p>第一题就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /FI &quot;imagename eq notepad.exe&quot;</span><br></pre></td></tr></table></figure><p>第二题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /PID 1516</span><br></pre></td></tr></table></figure><h3 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h3><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/task6.png" alt="task6"></p><p>shutdown &#x2F;r：重启计算机。<br>shutdown &#x2F;a：取消正在进行的关机或重启操作。</p><h2 id="windows-powershell"><a href="#windows-powershell" class="headerlink" title="windows powershell"></a>windows powershell</h2><p>接下来是powershell</p><p>废话不多说 我们看看task2</p><h3 id="task2-1"><a href="#task2-1" class="headerlink" title="task2"></a>task2</h3><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task2.png" alt="task2"></p><p>我们怎样称呼开发 PowerShell 所采用的高级方法？</p><p>答案:<strong>object-oriented</strong>(面向对象)</p><h3 id="task3-1"><a href="#task3-1" class="headerlink" title="task3"></a>task3</h3><p><strong>powershell基础</strong></p><h4 id="打开powershell"><a href="#打开powershell" class="headerlink" title="打开powershell"></a>打开powershell</h4><p>打开powershell有很多个方法</p><p> 1.开始菜单：powershell在 Windows 开始菜单搜索栏中输入，然后在结果中单击Windows PowerShell或。PowerShell</p><p>2 .运行对话框：按Win + R打开Run对话框，输入powershell，然后点击Enter。</p><p> 3.文件资源管理器：导航到任何文件夹，然后powershell在地址栏中输入，然后按Enter。这将在该特定目录中打开PowerShell 。</p><h4 id="cmdlet"><a href="#cmdlet" class="headerlink" title="cmdlet"></a>cmdlet</h4><p> PowerShell命令称为<strong>cmdlets</strong>。它们比传统的 Windows 命令功能更牛掰，并且允许进行更高级的数据操作。</p><p> Cmdlet 遵循一致的<strong>Verb-Noun</strong>8命名约定</p><p>eg：</p><ul><li><strong>Get-Content</strong>：检索（获取）文件的内容并将其显示在控制台中。</li><li><strong>Set-Location</strong>：更改（设置）当前工作目录。</li></ul><p>假如说你想看看有哪些可用的cmdlet啥的 可以用<strong>get-command</strong>这个命令</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/get-command.png" alt="getcommand"></p><p>还能在后面加个<strong>commandtype</strong>来筛选自己想要的东西</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/commandtype.png" alt="getcommand"></p><p>当然不懂的话 我们就用<strong>get-help</strong> 这里用的是get-data。我们可以通过在基本语法中添加一些选项来检索有关 cmdlet 的其他有用信息。</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/help.png" alt="help"></p><p>get-alias 列出了所有可用的别名<br><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/getalias.png" alt="getalias"></p><p>我们看一下题目</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task3.png" alt="task3"></p><p>第一题 如何检索remove开头命令？<br>用name筛选一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-command -name remove*</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/remove.png" alt="remove"></p><p>第二题 echo这个命令的别名叫啥?</p><p>用<strong>get-command -name</strong> 筛选一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-command -name echo</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/echo.png" alt="echo"></p><p>用于检索New-LocalUser的cmdlet 的一些示例用法的命令是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Help New-LocalUser -examples</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/localuser.png" alt="local"></p><h3 id="task4-1"><a href="#task4-1" class="headerlink" title="task4"></a>task4</h3><p>文件系统</p><p><strong>Get-ChildItem</strong>列出使用参数指定位置的文件和目录<strong>Path</strong>。它可用于探索目录并查看其内容。<br>如果未Path指定，则 cmdlet 将显示当前工作目录的内容。</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/getchilditem.png" alt="get"></p><p>要导航到其他目录，我们可以使用<strong>Set-Location</strong>。它会更改当前目录，将我们带到指定路径，类似于cd命令提示符中的命令。</p><p>要在PowerShell中创建一个项目，我们可以使用<strong>New-Item</strong>。</p><p><strong>Remove-Itemcmdlet</strong> 会同时删除目录和文件</p><p>我们可以分别使用<strong>Copy-Item</strong>（相当于copy）和<strong>Move-Item</strong>（相当于move）来复制或移动文件和目录。</p><p>读取和显示文件的内容，我们可以使用 <strong>cmdlet Get-Content</strong>，其工作方式与type命令提示符</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task4.png" alt="task4"></p><p>第一题 类似type的命令就是get-content</p><p>第二题  Get-ChildItem -Path C:\Users (Get-ChildItem之后要加个路径)</p><p>第三题数一下就知道了 四个</p><h3 id="task5-1"><a href="#task5-1" class="headerlink" title="task5"></a>task5</h3><p>管道(|) 是命令行环境中使用的一种技术，允许将一个命令的输出用作另一个命令的输入。</p><h4 id="where-object"><a href="#where-object" class="headerlink" title="where-object"></a>where-object</h4><p> 用于根据条件筛选对象。它会检查输入对象的属性，并根据指定的条件过滤出符合条件的对象。</p><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p><strong>&gt;-eq</strong>（即“等于”）是与其他脚本语言（例如 Bash、Python）共享的一组比较运算符的一部分。</p><p>-<strong>ne</strong>：“不等于”。此运算符可用于根据指定的条件从结果中排除对象。</p><p><strong>-gt</strong>：“大于”。此运算符将仅过滤超过指定值的对象。需要注意的是，这是一个严格的比较，这意味着等于指定值的对象将被排除在结果之外。</p><p><strong>-ge</strong>：“大于或等于-gt”。这是上一个运算符的非严格版本。与的组合-eq。</p><p><strong>-lt</strong>：“小于”。与“大于”类似，这是一个严格运算符。它仅包含严格低于某个值的对象。</p><p><strong>-le</strong>：“小于或等于”。与 类似，这是前一个运算符的非严格版本。和-ge的组合。-lt-eq</p><p>你已经掌握知识点了 现在我们来做一道题</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task5.png" alt="task5"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Get-ChildItem | Where-Object -Property Length -gt 100</span><br><span class="line"></span><br><span class="line">-Property Length:指定要检查的属性是 Length。对于文件对象,Length 属性表示文件的大小（以字节为单位）。</span><br><span class="line"></span><br><span class="line">-gt 100:-gt 是 “大于”的缩写，表示筛选出 Length 属性值大于 100 的对象。</span><br></pre></td></tr></table></figure><h3 id="task6-1"><a href="#task6-1" class="headerlink" title="task6"></a>task6</h3><p>系统与网络信息</p><p><strong>Get-ComputerInfocmdlet</strong> 可检索全面的系统信息，包括操作系统信息、硬件规格、BIOS 详细信息等。</p><p><strong>Get-LocalUser</strong>它列出了系统上的所有本地用户帐户。默认输出显示每个用户的用户名、帐户状态和说明。</p><p><strong>Get-NetIPConfiguration</strong>提供有关系统上网络接口的详细信息，包括 IP 地址、DNS服务器和网关配置。</p><p><strong>Get-NetIPAddresscmdlet</strong> 将显示系统上配置的所有 IP 地址的详细信息，包括当前不活动的 IP 地址。</p><p>简单科普了一下 开始看看题目</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task6.png" alt="task6"></p><p>第一题 我们直接输入<strong>get-localuser</strong> 一看就能看出多了一个用户p1r4t3</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/user.png" alt="task6"></p><p>第二题也可以顺便解出来 因为用户旁边的就是说明 正是题目需要的<br>A merry life and a short one.</p><p>第三题 其实也还好 一开始我以为要远程登录啥的 后来发现是我多虑了 </p><p>直接cd ..退回上一级文件夹 <strong>childitem</strong>一下 就能看到p1r4t3 这个用户的文件夹 </p><p>然后我们 <strong>set-location</strong> p1r4t3 进这个用户的文件夹 就能发现隐藏的宝藏 在进去就可以发现flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set-location Users</span><br><span class="line"></span><br><span class="line">set-location p1r4t3</span><br><span class="line"></span><br><span class="line">set-location hidden-treasure-chest</span><br><span class="line"></span><br><span class="line">get-content big-treasure.txt</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/flag1.png" alt="task6"></p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/flag2.png" alt="task6"></p><h3 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h3><p>实时系统分析</p><p><strong>Get-Process</strong>提供所有当前正在运行的进程的详细视图，包括CPU和内存使用情况，使其成为监控和故障排除的强大工具。</p><p><strong>Get-Service</strong>允许检索有关机器上服务状态的信息，例如哪些服务正在运行、停止或暂停。它被系统管理员广泛用于故障排除，也被取证分析师用于寻找系统上安装的异常服务</p><p><strong>Get-NetTCPConnection</strong>请显示当前TCP连接，深入了解本地和远程端点。此 cmdlet 在事件响应或恶意软件分析任务期间特别有用，因为它可以发现隐藏的后门或与攻击者控制的服务器建立的连接。</p><p><strong>Get-FileHash</strong>一个用于生成文件哈希的有用 cmdlet，它在事件响应、威胁搜寻和恶意软件分析中特别有价值，因为它有助于验证文件完整性并检测潜在的篡改。</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task7.png" alt="task7"></p><p>第一题 我们在刚才的那个文件夹里输入Get-FileHash命令来看他的hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-FileHash big-treasure-txt</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/hash.png" alt="task7"></p><p>第二题Get-NetTCPConnection 输出的信息中包含一个名为 OwningProcess 的属性，该属性表示每个 TCP 连接所属的进程 ID（PID）。</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/7.2.png" alt="task7"></p><p>第三题 这一题就很有意思了 题目说是服务 那就要用<strong>get-service</strong><br>我们用| where-object 后面就填我们提示说的displayname 题目说了说明和displayname有关 我们用<strong>-like “<em>merry</em>“</strong>来找出指定的服务 (你也可以直接在后面复制整个说明)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-service | where-object -like &quot;*merry*&quot; </span><br></pre></td></tr></table></figure><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/7.3.png" alt="task7"></p><h3 id="task8"><a href="#task8" class="headerlink" title="task8"></a>task8</h3><p>脚本<br><strong>Invoke-Command</strong>对于在远程系统上执行命令至关重要，因此它对于系统管理员、安全工程师和渗透测试人员来说至关重要。它Invoke-Command 可实现高效的远程管理，并结合脚本实现跨多台机器的任务自动化。它还可用于在渗透测试人员或攻击者的参与过程中在目标系统上执行有效载荷或命令。</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/powershell/task8.png" alt="task7"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Command -ComputerName RoyalFortune -ScriptBlock &#123;Get-Service&#125;</span><br></pre></td></tr></table></figure><h2 id="linux-shell"><a href="#linux-shell" class="headerlink" title="linux shell"></a>linux shell</h2><p>总算来到比较熟悉的地方了 linux还是懂点的 废话不多说开始吧</p><h4 id="task2-2"><a href="#task2-2" class="headerlink" title="task2"></a>task2</h4><p>要查看当前工作目录，可以执行<strong>pwd</strong>，它代表打印工作目录，<br>要查看目录的内容 可以用<strong>ls</strong>命令<br>读取文件的内容 用<strong>cat</strong>命令<br>grep 命令可以搜索文件内的任何单词或模式</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/task2.png" alt="task2"></p><ul><li>第一题 bash (echo $SHELL可以看你的linux shell当前版本)</li><li>第二题 ls </li><li>第三题 grep</li></ul><h3 id="task3-2"><a href="#task3-2" class="headerlink" title="task3"></a>task3</h3><p>cat &#x2F;etc&#x2F;shell可以列出Linux 操作系统中可用的 shell</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/task3.png" alt="task3"></p><ul><li>第一题 fish</li><li>第二题 bash</li><li>第三题 history</li></ul><h3 id="task4-2"><a href="#task4-2" class="headerlink" title="task4"></a>task4</h3><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/task4.png" alt="task3"></p><ul><li>第一题 #!&#x2F;bin&#x2F;bash</li><li>第二题 chmod +x</li><li>第三题 loops</li></ul><h3 id="task5-2"><a href="#task5-2" class="headerlink" title="task5"></a>task5</h3><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/task5.png" alt="task3"></p><p>在看文章的时候 文章说了pin是7385</p><p>答案为7385</p><h3 id="task6-2"><a href="#task6-2" class="headerlink" title="task6"></a>task6</h3><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/task6.png" alt="task3"></p><p>我们来看题目要求 进入机子的&#x2F;home&#x2F;user的脚本里面 将三个空修改完</p><p>第一个空是填文件的路径 &#x2F;var&#x2F;log</p><p>第二个空是把文章里面的flag填进去</p><p>第三个空要填$directory （$directory&#x2F;*.log 是一个模式匹配表达式，表示 &#x2F;var&#x2F;log 目录下所有以 .log 结尾的文件。）</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/cat.png" alt="task3"></p><p>将脚本改完之后 我们开始运行脚本 脚本告诉我们 flag在authentication.log里面</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/cat1.png" alt="task3"></p><p>我们用cat搜索一下authentication.log里的关键词 成功搜索到</p><p><img src="/images/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C/linux/cat2.png" alt="task3"></p><p>OK 传说的三位 我们已经介绍完毕 还有很多内容要我们学习 这些只是个皮面 keep moving</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux windows shell 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Active Directory Basics教程</title>
      <link href="/2025/01/20/Active-Directory-Basics%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/20/Active-Directory-Basics%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Active Directory Basics教程<br>这个只能说没遇到过 在未来工作管理中还蛮适合的 就是可以管理用户和计算机的好工具 </p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/title.png" alt="ad"></p><p><strong>Active Directory</strong>（活动目录）是微软Windows操作系统中用于存储网络资源信息和管理网络用户权限的一种目录服务。它在企业级网络环境中广泛使用，主要用于集中管理用户账户、计算机、组织单位、组策略等网络资源。</p><p>Windows 计算机网络的通用组件的管理集中在一个名为<strong>Active Directory  ( AD )</strong> 的存储库中。运行 Active Directory 服务的服务器称为<strong>Domain Controller 域控制器 ( DC )。</strong></p><h2 id="Active-Directory作用"><a href="#Active-Directory作用" class="headerlink" title="Active Directory作用"></a>Active Directory作用</h2><ul><li>1.<strong>集中管理用户和计算机</strong>：Active Directory可以集中管理网络中的用户账户和计算机。管理员可以通过它创建、修改、删除用户账户和计算机账户，统一管理用户的登录权限和计算机的访问权限。<br>  </li><li>2.<strong>组织单位管理</strong>：可以创建组织单位（OU），将用户和计算机按部门、地理位置等进行分类管理，方便对不同组织单位应用不同的策略和管理操作。<br></li><li>3.<strong>组策略应用</strong>：通过Active Directory可以将组策略应用到用户和计算机上。组策略可以控制用户的桌面环境、软件安装、安全设置等，实现对网络环境的统一配置和管理。<br></li><li>4.<strong>资源访问控制</strong>：可以设置用户对网络资源（如文件服务器、打印机等）的访问权限，确保只有授权用户可以访问特定资源。<br></li><li>5.<strong>身份验证和授权</strong>：Active Directory提供身份验证和授权机制，确保用户在登录网络时的身份合法性，并根据用户的权限进行授权操作。</li></ul><p>科普完之后咱开始看题</p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/task2.png" alt="task2"></p><p>这一题就是科普题</p><p>1.在Windows域中，凭据被存储在一个的集中式存储库 存储库叫什么名字？</p><p>Active Directory</p><p>2.负责运行Active Directory服务的服务器被称为？</p><p>Domain Controller</p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p>先看看怎么打开ad吧 在电脑中找了一波 就是没发现ad在哪。在问过大模型之后 发现AD是运行在Windows Server上的服务。我们电脑应该应该没 真的要这个功能需要下载 搞很多东西 这里就不搞了</p><p>这个是ad的默认组</p><ul><li><strong>域管理员(Domain Admins)</strong>该组的用户拥有整个域的管理权限。默认情况下，他们可以管理域中的任何计算机，包括 DC。</li><li><strong>务器操作员(Server Operators)</strong>此组中的用户可以管理域控制器。他们无法更改任何管理组成员身份。</li><li><strong>份操作员(Backup Operators)</strong>此组中的用户可以访问任何文件，而不受其权限的限制。它们用于执行计算机上的数据备份。</li><li><strong>账户操作员(Account Operators)</strong>该组中的用户可以创建或修改域中的其他帐户。</li><li><strong>域用户(Domain Users)</strong>包括域中所有现有的用户帐户。</li><li><strong>域计算机(Domain Computers)</strong>包括域中所有现有的计算机。</li><li><strong>域控制器(Domain Controllers)</strong>包括域中所有现有的 DC。</li></ul><p>识别机器帐户相对容易。它们遵循特定的命名方案。机器帐户名称是计算机的名称后跟美元符号。例如，名为的机器DC01将有一个名为的机器帐户**DC01$**。</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/task3.png" alt="task"></p><p>我们接着看看task3的题目 依旧科普题</p><p>1.<strong>Domain Admins</strong> 该组的用户拥有整个域的管理权限 一般可以直接管理所有计算机</p><p>2.<strong>“tom-pc$”</strong>  命名这些机器账户就是在名字后面加个美元符号</p><p>第三题就是 organizational units</p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/task4.png" alt="task4"></p><p>我们来看第一问 我们现在windows的搜索框搜一下这个</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/group.png" alt="task4"></p><p>进去之后 我们随便点一下文件 出现以下的框框 点击第一个</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/ad1.png" alt="task4"></p><p>我们点击add 添加philip这个用户(题目提供了这个账户给我们) 给他给别的用户重设密码的权限</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/ad2.png" alt="task4"></p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/ad3.png" alt="task4"></p><p>改完之后我们远程登录phillip ip就是tryhackme提供的ip</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/rd.png" alt="task4"></p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/login.png" alt="task4"></p><p>登录之后我们用powershell来重设shphile的账户 <strong>记住密码要符合一定的复杂程度！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ADAccountPassword sophie -Reset -NewPassword (Read-Host -AsSecureString -Prompt &#x27;New Password&#x27;) -Verbose</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ADUser -ChangePasswordAtLogon $true -Identity sophie -Verbose</span><br></pre></td></tr></table></figure><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/setpasswd.png" alt="task4"></p><p>一切就绪 我们开始远程登录</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/sophlogin.png" alt="login"></p><p>进入桌面就能看到flag</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/flag.png" alt="login"></p><p>第二问 向用户授予某些 OU 或其他 AD 对象的权限的过程称为<br><strong>delegation</strong></p><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/task5.png" alt="task5"></p><p>第一问挺有意思的 </p><p>只能说我一开始是没搞明白啥意思</p><p>我们在Windows的搜索栏搜一下users</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/group.png" alt="task5"></p><p>点进去照着图这么设置 显示出所有的东西</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/fix.png" alt="task5"></p><p>找到computer这个组</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/fix2.png" alt="task5"></p><p>将这里的勾去掉</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/fix3.png" alt="task5"></p><p>然后点击thm.local 新建两个文件一个是servers另一个是workstations</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/fixxx.png" alt="task5"></p><p>恭喜<del>你被我恭喜到了</del>以上是让你熟悉熟悉操作的 打开computer那个组 把s开头的那几个减掉 就是第一题的答案</p><p>第二题当然是yay</p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p>Windows 通过<strong>组策略对象</strong> ( GPO )管理此类策略。GPO 只是可应用于 <strong>OU</strong>的设置集合。GPO 可以包含针对用户或计算机的策略，</p><p>GPO 通过名为 的网络共享分发到网络<strong>SYSVOL</strong>，该共享存储在 DC 中。域中的所有用户通常都应能够通过网络访问此共享，以定期同步其 GPO。SYSVOL 共享默认指向C:\Windows\SYSVOL\sysvol\我们网络中每个 DC 上的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpupdate /force</span><br></pre></td></tr></table></figure><p>我们看一下题目</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/task6.png"></p><p>第一题是通过sysvol将gpo分发到域机器</p><p>第二题 gpo可以将设置应用在用户和计算机</p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p>身份验证方法</p><p>Windows 域中的网络身份验证可以使用两种协议：<br><strong>Kerberos</strong>：任何较新版本的 Windows 均使用此协议。这是任何较新域中的默认协议。</p><p><strong>NetNTLM</strong>：为了兼容性目的而保留的旧式身份验证协议。</p><h3 id="Kerberos身份验证"><a href="#Kerberos身份验证" class="headerlink" title="Kerberos身份验证"></a>Kerberos身份验证</h3><p>Kerberos身份验证是 Windows 最新版本的默认身份验证协议。使用Kerberos登录服务的用户将被分配票证。将票证视为先前身份验证的证明。拥有票证的用户可以将其出示给服务，以证明他们之前已通过网络身份验证，因此可以使用该服务。</p><p>当使用Kerberos进行身份验证时，会发生以下过​​程：</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>用户将其用户名和使用从其密码派生的密钥加密的<strong>时间戳</strong>发送到<strong>密钥分发中心 (KDC)<strong>，kdc负责在网络上创建</strong>Kerberos票证</strong>。</p><p><strong>KDC</strong>将创建并返回一个票证授予**票证 ( TGT )**，这将允许用户请求更多票证以访问特定服务。需要票证才能获得更多票证听起来可能有点奇怪，但它允许用户在每次想要连接到服务时请求服务票证而无需传递其凭据。除了 TGT 之外，还会向用户提供会话密钥，他们将需要该密钥来生成以下请求。</p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>当用户想要连接到网络上的服务（如共享、网站或数据库）时，他们将使用其TGT向 KDC 请求**票证授予服务 (TGS)**。TGS 是仅允许连接到为其创建的特定服务的票证。要请求 TGS，用户将发送使用会话密钥加密的用户名和时间戳，以及 TGT和服务主体名称 (SPN)，后者指示我们打算访问的服务和服务器名称。</p><p>因此，KDC 将向我们发送 TGS 以及服务会话密钥，我们需要该密钥来验证我们要访问的服务。TGS 使用从 服务所有者哈希派生的密钥进行加密。服务所有者是服务在其下运行的用户或机器帐户。TGS 在其加密内容中包含服务会话密钥的副本，以便服务所有者可以通过解密 TGS 来访问它。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>然后，TGS 可以发送到所需的服务以进行身份​​验证并建立连接。该服务将使用其配置的帐户的密码哈希来解密 TGS 并验证服务会话密钥。</p><h3 id="NetNTLM-身份验证"><a href="#NetNTLM-身份验证" class="headerlink" title="NetNTLM 身份验证"></a>NetNTLM 身份验证</h3><p>NetNTLM 采用质询-响应机制。 整个过程如下：</p><p>1.客户端向其想要访问的服务器发送身份验证请求。<br>2.服务器生成一个随机数并将其作为挑战发送给客户端。<br>3.客户端将其NTLM密码哈希与质询（和其他已知数据）相结合，以生成对质询的响应并将其发送回服务器进行验证。<br>4.服务器将质询和响应转发给域控制器进行验证。<br>5.域控制器使用该质询重新计算响应，并将其与客户端发送的原始响应进行比较。 如果两者匹配，则客户端通过身份验证； 否则，访问被拒绝。 身份验证结果将发送回服务器。<br>6.服务器将认证结果转发给客户端。</p><p>请注意，出于安全考虑，用户的密码（或哈希值）绝不会通过网络传输。</p><hr><p>任务七的题目在这</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/task7.png" alt="task7"></p><p>第一题 Windows是默认使用<strong>Kerberos</strong> 所以填nay</p><p>第二题 当用户想要连接到网络上的服务（如共享、网站或数据库）时，他们将使用其<strong>TGT</strong>向 KDC 请求票证授予服务 (TGS) tgt就是答案</p><p>第三题 密码不会通过网络传输 填nay</p><h2 id="task8"><a href="#task8" class="headerlink" title="task8"></a>task8</h2><p>trees forests and trusts</p><h3 id="trees"><a href="#trees" class="headerlink" title="trees"></a>trees</h3><p>Active Directory 支持集成多个域，这样就可以将网络划分为可以独立管理的单元。如果您有两个共享<strong>相同命名空间</strong>的域，则可以将这些域合并为一个**tree(树)**。</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/tree.png" alt="tree"></p><h3 id="forests"><a href="#forests" class="headerlink" title="forests"></a>forests</h3><p>将具有<strong>不同命名空间</strong>的多个树合并到<strong>同一个网络</strong>中称为<strong>forest森林</strong>。</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/forest.png" alt="forest"></p><h3 id="trusts"><a href="#trusts" class="headerlink" title="trusts"></a>trusts</h3><p>以树和森林形式组织的多个域可让您在管理和资源方面拥有良好的分区网络。但在某个时候，alice的用户可能需要访问bob 服务器之一中的共享文件。为此，以树和森林形式组织的域通过信任关系连接在一起。</p><p>还可以建立双向信任关系，以允许两个域相互授权对方的用户。默认情况下，将多个域加入一棵树或一个森林下将形成双向信任关系。</p><p><img src="/images/Active-Directory-Basics%E6%95%99%E7%A8%8B/8.png" alt="task8"></p><p>第一题就是tree<br>第二题是a trust relationship   </p><p>也算是做完这个了 就是熟悉活动目录 以及对用户和组的一些管理 了解了解一些功能。太太太粪怪了 没多大意思</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows 用户与组 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anonforce教程</title>
      <link href="/2025/01/19/anonforce%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/19/anonforce%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们开始第一次的ctf的测试 练练手 我们开始搞这个anonforce</p><p><img src="/images/anonforce/title.png" alt="title"></p><h2 id="1-nmap扫描"><a href="#1-nmap扫描" class="headerlink" title="1.nmap扫描"></a>1.nmap扫描</h2><p>首先nmap扫描一波</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -sV -A ip</span><br></pre></td></tr></table></figure><p><img src="/images/anonforce/nmap1.png" alt="nmap"></p><p><img src="/images/anonforce/nmap2.png" alt="nmap"></p><h2 id="2-ftp服务器里面搞东西"><a href="#2-ftp服务器里面搞东西" class="headerlink" title="2.ftp服务器里面搞东西"></a>2.ftp服务器里面搞东西</h2><p>我们会发现扫出来两个端口 <strong>21 ftp端口</strong>和<strong>22 openssh端口</strong><br>而ftp端口我们可以匿名登录 用户名就是anonymous 密码随意 </p><p><img src="/images/anonforce/ftplogin.png" alt="ftp"></p><p>我们成功登录进去了</p><p>ls查看一下有啥文件 发现一个notread的文件 </p><p><img src="/images/anonforce/ftplook.png" alt="ftp"></p><p>进去看看有啥东西吗</p><p><img src="/images/anonforce/ftpcd.png" alt="ftp"></p><p>可以使用<strong>get 文件名</strong>来下载或者是<strong>mget *</strong><br>我用mget * 还挺方便的一次性下载好</p><p><img src="/images/anonforce/mget.png" alt="ftp"></p><p>接着我们在ftp里面再找找还有啥线索吗 其实我是看了教程才知道user.txt在该死的&#x2F;home里面 直接进去就可以搞到第一题答案 下次遇到这种先进去看看</p><p><img src="/images/anonforce/home.png" alt="ftp"></p><h2 id="3-破解文件"><a href="#3-破解文件" class="headerlink" title="3.破解文件"></a>3.破解文件</h2><p>其实这个就是最难的 本身也没接触过这个破解的工具<br>现在咱把ftp服务器退了 我们来看一下我们下载的东西 分别是<strong>backup.pgp</strong>和<strong>private.asc</strong> 这两个是关键</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>我们要先把private.asc搞出来 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gp2john /root/private.asc &gt; /root/hash_for_john</span><br></pre></td></tr></table></figure><p>这个命令是将<strong>加密信息</strong>转换为 John the Ripper <strong>可以识别的哈希格式</strong></p><p>后面两个其实就是自己的文件的路径就行 不是一定要上面这个 </p><p><img src="/images/anonforce/john.png" alt="po"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>我们把刚才搞好的john_for_hash这个文件拉到john里面去破解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john hash_for_john</span><br></pre></td></tr></table></figure><p><img src="/images/anonforce/johnhaxi.png" alt="john"></p><p>我们能得出密码是xbox360</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>导入私钥 将我们得到的密码xobx360输进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --import private.asc</span><br></pre></td></tr></table></figure><p><img src="/images/anonforce/import.png" alt="daoru"></p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>解密backup.pgp </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john hash --wordlist=/usr/share/wordlists/rockyou.txt</span><br></pre></td></tr></table></figure><p><img src="/images/anonforce/jieimi.png" alt="jiemi"></p><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>解密之后我们会发现 这个有点貌似是<strong>shadow</strong>文件 存储着密码</p><p><img src="/images/anonforce/pgp.png" alt="mima"></p><p>我们将root的密码复制出来 粘贴到一个新建的文本文件里面 然后用john去破解 就可以得到密码是hikari</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john hash --wordlist=/usr/share/wordlists/rockyou.txt</span><br></pre></td></tr></table></figure><p><img src="/images/anonforce/jieimi.png" alt="root"></p><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>得到了root的密码 我们直接ssh连接 连接成果之后 root.txt就静静地等着你的到来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure><p><img src="/images/anonforce/root.png" alt="ssh"></p><p>这个难的地方就是 我没接触过John the Ripper 虽然略有所谓 但是没实战操作过 有些地方不太熟悉 特别是转换为john可以识别的格式和用john解密。挺好的机会去学习这个工具</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf linux 密码破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux System Hardening教程</title>
      <link href="/2025/01/19/Linux-System-Hardening%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/19/Linux-System-Hardening%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次遇到困难难度的题 有点意思 怕不会是个难关哦 </p><p><img src="/images/Linux%20System%20Hardening/linux.png" alt="title"></p><p>本房间涵盖了与Linux强化相关的各种主题。在本房间结束时，将通过以下方式了解有关如何提高Linux系统安全性的更多信息：</p><ul><li><strong>物理安全</strong></li><li><strong>文件系统加密</strong></li><li><strong>防火墙配置</strong></li><li><strong>远程访问</strong></li><li><strong>软件和服务</strong></li><li><strong>更新和升级</strong></li><li><strong>日志</strong></li></ul><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p>这个是讲物理安全</p><p>我们可以根据要保护的Linux系统考虑添加GRUB密码。许多工具都有助于实现这一点。其中一个工具是，它会提示您输入两次密码并为您生成哈希值。生成的哈希值应根据Linux发行版（例如：Fedora和Ubuntu）添加到相应的配置文件中。此配置将阻止未经授权的用户重置您的 root 密码。它将要求用户提供密码才能通过GRUB访问高级启动配置，包括以 root 访问权限登录。<strong>grub2-mkpasswd-pbkdf2</strong></p><p>我们能在文章中发现第一题的答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkpasswd-pbkdf2</span><br></pre></td></tr></table></figure><p>grub2-mkpasswd-pbkdf2 是一个命令行工具，用于生成加密的密码哈希。</p><p>生成的密码哈希使用 <strong>PBKDF2</strong>（Password-Based Key Derivation Function 2）算法，这是一种安全的密码哈希算法，可以有效防止彩虹表攻击和暴力破解。</p><p>第二题也得出答案了 <strong>Password-Based Key Derivation Function 2</strong></p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p>这个讲的是文件系统分区与加密</p><p>luks(全称是<strong>Linux Unified Key Setup</strong> 是Linux系统中广泛使用的磁盘加密规范，它提供了一种强大且用户友好的标准化加密机制，通过对物理和逻辑磁盘分区内的数据进行加密来保护数据，确保只有授权用户才能访问加密分区的内容。)</p><p>luks结构</p><p><img src="/images/Linux%20System%20Hardening/disk.png" alt="disk"></p><ul><li>LUKS phdr：它代表<strong>LUKS分区头</strong>。LUKS phdr存储有关UUID（通用唯一标识符）、使用的密码、密码模式、密钥长度和主密钥的校验和的信息。<br></li><li>KM：KM 代表<strong>密钥材料</strong>，其中有 KM1、KM2、…、KM8。每个密钥材料部分都与一个密钥槽相关联，该密钥槽可以在LUKS phdr 中指示为活动状态。<br>换句话说，我们可能使用第一个用户的密码加密主密钥并保存在 KM1 中，使用第二个用户的密码加密主密钥并保存在 KM2 中，依此类推。<br></li><li>批量数据：这是指<strong>使用主密钥加密的数据</strong>。主密钥保存在密钥材料部分中，并使用用户的密码进行加密。</li></ul><p>我们看看问题</p><p><img src="/images/Linux%20System%20Hardening/task3.png" alt="task3"></p><p>第一问 luks全称叫<strong>Linux Unified Key Setup</strong></p><p>第二问真的有难度 看看提示 把提示的命令粘贴进去</p><p><img src="/images/Linux%20System%20Hardening/3.png" alt="3"></p><p>然后到myvault里面就能看到答案</p><p><img src="/images/Linux%20System%20Hardening/3%201.png" alt="3"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cryptsetup open --type luks secretvault.img myvault &amp;&amp; sudo mount /dev/mapper/myvault myvault/</span><br></pre></td></tr></table></figure><h3 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h3><p> <strong>sudo cryptsetup open –type luks secretvault.img  myvault</strong></p><ul><li><strong>sudo</strong>：以超级用户权限运行命令，因为解密和挂载操作通常 需要管理员权限。</li><li><strong>cryptsetup</strong>：用于管理加密设备的命令行工具。</li><li><strong>open</strong>：cryptsetup的子命令，用于打开一个加密设备。</li><li><strong>–type luks</strong>：指定加密设备的类型为LUKS（Linux  Unified Key Setup）。</li><li><strong>secretvault.img</strong>：加密图像文件的路径。</li><li><strong>myvault</strong>：解密后的设备映射器名称，用于在&#x2F;dev&#x2F; mapper&#x2F;下创建一个设备节点。<br> 这个命令的作用是将<strong>secretvault.img</strong>文件解密，并创建一个 设备映射器&#x2F;dev&#x2F;mapper&#x2F;myvault，以便后续可以挂载这个设备。</li></ul><hr><p><strong>sudo mount &#x2F;dev&#x2F;mapper&#x2F;myvault myvault&#x2F;</strong></p><ul><li><strong>sudo</strong> ：以超级用户权限运行命令。</li><li><strong>mount</strong>：用于挂载文件系统的命令。</li><li><strong>&#x2F;dev&#x2F;mapper&#x2F;myvault</strong>：解密后的设备映射器路径。</li><li><strong>*myvault&#x2F;</strong>：挂载点目录，解密后的文件系统将挂载到这个目录。</li></ul><p>这个命令的作用是将解密后的设备&#x2F;dev&#x2F;mapper&#x2F;myvault挂载到myvault&#x2F;目录，使得你可以访问其中的文件</p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p>这一个部分讲的是防火墙</p><p>设置防火墙有很多安全优势。首先，防火墙规则可以精细控制哪些数据包可以离开系统以及哪些数据包可以进入系统。因此，防火墙规则通过控制设备之间的网络流量来帮助减轻各种安全风险。</p><p>更重要的是，可以制定防火墙规则来确保没有客户端可以充当服务器。换句话说，攻击者无法在目标计算机上启动可访问的侦听端口；漏洞利用者可以启动侦听端口，但防火墙将阻止所有传入的连接尝试。</p><p>  防火墙有两个主要功能：</p><ul><li>1.什么可以进入？允许或拒绝数据包进入系统。</li><li>2.什么可以离开？允许或拒绝数据包离开系统。</li></ul><p>进入防火墙规则的 IP 标头字段包括：</p><ul><li>源 IP 地址</li><li>目标 IP 地址</li></ul><p>防火墙规则主要关注的TCP &#x2F; UDP标头字段是：</p><ul><li>源TCP &#x2F; UDP端口</li><li>目标TCP &#x2F; UDP端口</li></ul><p>netfilter 为Linux内核 2.4.x 及更高版本提供数据包过滤软件。netfilter 需要(例如<strong>iptables</strong>或 <strong>nftables</strong>来管理。)</p><p>说有点多了 我们直接看题</p><p><img src="/images/Linux%20System%20Hardening/firewall.png" alt="task4"></p><p>前面提到<strong>iptables</strong> 我们就直接用iptables列出防火墙的规则 用grep过滤出我们想要的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables --list | grep tcp</span><br><span class="line">iptables --list | grep ucp</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20System%20Hardening/tcp.png" alt="task4"></p><p><img src="/images/Linux%20System%20Hardening/udp.png" alt="task4"></p><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p>远程访问<br>常见的攻击包括：</p><ul><li>密码嗅探</li><li>密码猜测和暴力破解</li><li>利用监听服务</li></ul><p><img src="/images/Linux%20System%20Hardening/task5.png" alt="task5"></p><p>查看sshd_config的隐藏 flag</p><p>直接进入&#x2F;etc&#x2F;ssh&#x2F;sshd_config查看就行了</p><p><img src="/images/Linux%20System%20Hardening/sshd.png" alt="sshd"></p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p>讲的是用户账户安全</p><h3 id="使用-sudo"><a href="#使用-sudo" class="headerlink" title="使用 sudo"></a>使用 sudo</h3><p>为了避免以身份登录root，更好的方法是将为管理目的创建的帐户添加到<strong>sudoers</strong> （即可以使用该sudo命令的组）。sudo代表超级用户执行，它应该在任何需要root特权的命令之前。</p><p>据Linux发行版，我们可以通过以下方式将用户添加到 sudoers 组。某些发行版（例如 Debian 和 Ubuntu）将 sudoers 称为组<strong>sudo</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo username</span><br></pre></td></tr></table></figure><p>其他发行版（例如 RedHat 和 Fedora）将 sudoers 组称为<strong>wheel</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG wheel username  </span><br></pre></td></tr></table></figure><h3 id="禁用未使用的用户"><a href="#禁用未使用的用户" class="headerlink" title="禁用未使用的用户"></a>禁用未使用的用户</h3><p>一种简单的方法是编辑<strong>&#x2F;etc&#x2F;passwd</strong>文件并将我们要禁用的用户帐户的 shell 设置为&#x2F;sbin&#x2F;nologin。</p><h3 id="禁用-root"><a href="#禁用-root" class="headerlink" title="禁用 root"></a>禁用 root</h3><p>一旦创建了用于管理目的的帐户并将其添加到<strong>sudo&#x2F;wheel</strong>组，您可能会考虑禁用该root帐户。<br>一种直接的方法是修改<strong>&#x2F;etc&#x2F;passwd</strong> 将 shell 更改root为<strong>&#x2F;sbin&#x2F;nologin</strong>。换句话说，编辑&#x2F;etc&#x2F;passwd并将行更改<strong>bin&#x2F;bash</strong> 为 <strong>&#x2F;sbin&#x2F;nologin</strong>。</p><p>我们看看题目</p><p><img src="/images/Linux%20System%20Hardening/task6.png" alt="task6"></p><p>第一题&#x2F;sbin&#x2F;nologin</p><p>第二题很显而易见 wheel</p><p>第三题sudo</p><p>第四题 问sudo组里面还有谁 我们之间grep一下&#x2F;etc&#x2F;group就可以知道1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat group | grep sudo</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20System%20Hardening/group.png" alt="group"></p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p>软件和服务</p><p>系统上安装的每款软件都会增加潜在漏洞的数量。换句话说，安装额外的软件包和新服务会增加攻击者可利用的漏洞，从而访问系统，并最终访问网络上的其他系统。</p><ul><li><p>禁用不必要的服务<br>改善安全状况的最简单方法之一是删除或禁用不需要的服务和软件包。每个软件包都有一定的风险，而且我们无法知道何时会发现相关的漏洞。</p></li><li><p>阻止不需要的网络端口<br>删除所有不需要的软件包并禁用可能不会被删除的预安装服务后，相应地设置防火墙规则至关重要。</p></li><li><p>避免使用遗留协议<br>过去，Telnet 曾是远程访问系统的主要协议；TFTP 协议通常用于传输文件。随着安全替代方案的发布，不应再允许使用此类协议。</p></li><li><p>eg：<br>SSH协议现已广泛使用，取代了 Telnet 。例如，安全文件传输议 (<strong>SFTP</strong>) 协议为 TFTP 协议提供了很好的替代方案。关键在选择和使用安全的替代方案。</p></li><li><p>删除识别字符串<br>每当你连接到远程服务器时，它通常会回复其版本号。此信息会向攻击者透露各种信息，例如服务器&#x2F;程序的名称、版本号和主机操作系统。</p></li></ul><p>根据上面的文字 能知道 task7的答案是sftp(替代了tftp)</p><h2 id="task8"><a href="#task8" class="headerlink" title="task8"></a>task8</h2><p>升级和更新策略<br>以下两个命令更新基于 Debian 的发行版，例如 Ubuntu：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update从配置的源下载包信息</span><br><span class="line">apt upgrade从配置的源安装所有软件包的可用升级</span><br></pre></td></tr></table></figure><p>以下命令更新 RedHat 或 Fedora 系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf update在较新版本上（Red Hat Enterprise Linux 8 及更高版本）</span><br><span class="line">yum update在旧版本上（Red Hat Enterprise Linux 7 及更早版本）</span><br></pre></td></tr></table></figure><p>这个是题目</p><p><img src="/images/Linux%20System%20Hardening/task8.png" alt="task8"></p><p>前面几题其实就是基础知识 百度啥的都可以知道 直接复制粘贴就完了</p><p>最后一题的话 进&#x2F;etc&#x2F;apt&#x2F;source.list就可以看到flag</p><p><img src="/images/Linux%20System%20Hardening/source.png" alt="source"></p><h2 id="task9"><a href="#task9" class="headerlink" title="task9"></a>task9</h2><p><img src="/source/images/Linux%20System%20Hardening/task9.png" alt="task9"></p><p>这两天就是看你的<strong>tail</strong>和<strong>grep</strong>命令的使用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -n 15 kern.log</span><br><span class="line">grep denied source</span><br></pre></td></tr></table></figure><p>结束这场战斗了 算比较深一点点了解linux在安全上的各种措施。要把这些用在实际的地方在是关键</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux 安全 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Fundamentals 1~3教程</title>
      <link href="/2025/01/18/Windows-Fundamentals-1%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/18/Windows-Fundamentals-1%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在搞一个比较简单的windows Fundamentals 其实Windows我也是学习中 基本的功能也算半桶水</p><h2 id="windows基本功能1"><a href="#windows基本功能1" class="headerlink" title="windows基本功能1"></a>windows基本功能1</h2><p>现在是windows基本功能1 只能说基础 得打牢</p><p>就是了解了解windows的功能 各种系统自带的程序的作用</p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/1.png" alt="1"></p><h3 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h3><p>task2就跳过了 无法启用bitlocker</p><h3 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h3><p>讲的是桌面的组成 桌面又称为图形用户界面或简称GUI</p><p>分为一下几个部分</p><ul><li>桌面</li><li>开始菜单</li><li>搜索框（Cortana）</li><li>任务视图</li><li>任务栏</li><li>工具栏</li><li>通知区域</li></ul><p>我们看看问题<br><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/task3.png" alt="问题"></p><p>其实这些问题很容易 就是吃了不太懂这些东西的英文叫啥</p><h4 id="问题一-如何隐藏-禁用搜索框"><a href="#问题一-如何隐藏-禁用搜索框" class="headerlink" title="问题一 如何隐藏&#x2F;禁用搜索框"></a>问题一 如何隐藏&#x2F;禁用搜索框</h4><p>右键点击下方的空白处 调出任务栏 点search搜索 就会有个隐藏</p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/hidden.png" alt="任务栏"></p><h4 id="问题二-隐藏任务视图"><a href="#问题二-隐藏任务视图" class="headerlink" title="问题二 隐藏任务视图"></a>问题二 隐藏任务视图</h4><p>还是那个地方 任务视图叫task view 点击show task view button</p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/show%20task.png" alt="task"></p><h4 id="问题三-还有哪些图标"><a href="#问题三-还有哪些图标" class="headerlink" title="问题三 还有哪些图标"></a>问题三 还有哪些图标</h4><p>在时间和网络的旁边 有个小框框 那个就答案 名字叫做action center</p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/action.png" alt="tu"></p><h3 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h3><p>ntfs叫做<strong>New Technology File System</strong></p><h3 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h3><p>windows文件夹系统变量%windir%</p><h3 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h3><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/task6.png" alt="task6"></p><p>看到有用户 账户 我们直接cmd 输入<strong>lusrmgr.msc</strong> </p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/other.png" alt="user"></p><p>一下子找到另一个用户和他的描述 第一题第四题解决<br>另一个账户叫<strong>tryhackmebilly</strong> 描述是<strong>window$Fun1!</strong></p><p>点击tryhackmebilly账户 我们选到有member的选项</p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/mumer.png" alt="group"></p><p>发现是属于remote desktop user和user的用户</p><p>内置账户可以用于访问访客计算机 当然是guest用户</p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p>uac是user account control 用户账户控制</p><h2 id="task8"><a href="#task8" class="headerlink" title="task8"></a>task8</h2><p>cmd 输入<strong>control</strong> 进入控制列表 选择类别 小图标 最后一个是Windows defender firewall</p><p><img src="/images/Windows%20Fundamentals%201%E6%95%99%E7%A8%8B/small.png" alt="control"></p><h2 id="task9"><a href="#task9" class="headerlink" title="task9"></a>task9</h2><p>打开任务管理器的键盘快捷键是什么</p><p>ctrl+shift+esc</p><h2 id="windows基本功能2"><a href="#windows基本功能2" class="headerlink" title="windows基本功能2"></a>windows基本功能2</h2><p>接下来是windows基本功能2</p><p><img src="/2025/01/18/Windows-Fundamentals-1%E6%95%99%E7%A8%8B/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/2.png" alt="2"></p><h2 id="task2-1"><a href="#task2-1" class="headerlink" title="task2"></a>task2</h2><p>我们看看题目</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/task2.png" alt="task2"></p><p>我们cmd输入<strong>msconfig</strong> 系统配置</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>题目是说服务 我们点开services 点一下manufacturer筛选一下 从底部开始显示 一下子就能找到 Systems Internals的服务是<strong>psshutdown</strong></p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/man.png" alt="msc"></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>题目说是Windows 我们在tool里面看 关于Windows <strong>about Windows</strong>点击之后点一下下面的launch</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/windowsuser.png" alt="windows"></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>Windows排除故障 我们还是在在系统配置中的tools中找到troubleshooting 点击一下 下方就有显示具体的程序</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/trub.png"></p><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>控制面板就不用多说 不用想都是control 我们真要去系统配置找的话 我们就依然在tools中找到control</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/control.png" alt="contorl"></p><h2 id="task3-1"><a href="#task3-1" class="headerlink" title="task3"></a>task3</h2><p>我们也是在系统配置的tools进行查找<br>可以发现是<strong>UserAccountControlSettings.exe</strong></p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/uac2.png" alt="task3"></p><h2 id="task4-1"><a href="#task4-1" class="headerlink" title="task4"></a>task4</h2><p>我们看一下题目吧</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/task4.png" alt="task4"></p><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><p>第一题和之前的一样在系统配置中的tools找计算机管理 <strong>computer management</strong></p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/compmgmt.png" alt="man"></p><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><p>这题我们要打开计算机管理的任务计划程序 在里面找到题目要求的程序 发现是6:15am</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/ua.png" alt="ua"></p><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><p>我们在这个界面找到共享文件夹 点进去就可以发现答案</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/share.png" alt="share"></p><h2 id="task5-1"><a href="#task5-1" class="headerlink" title="task5"></a>task5</h2><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/task5.png" alt="task5"></p><h3 id="第一题和第二题"><a href="#第一题和第二题" class="headerlink" title="第一题和第二题"></a>第一题和第二题</h3><p>我们又又又又在在系统配置中查找system infomation 找到之后单击launch 就可以找到第二题答案</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/msinfo32.png" alt="diyiti"></p><h3 id="第三题-2"><a href="#第三题-2" class="headerlink" title="第三题"></a>第三题</h3><p>环境变量就在系统信息中 在cmd中输入<strong>msinfo32</strong> 进入系统信息 找到software enviroment的enviroment variables 就能看到ComSpec的值</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/envir.png" alt="disanti"></p><h2 id="task6-1"><a href="#task6-1" class="headerlink" title="task6"></a>task6</h2><p>在系统配置中的tools能找到 Resource Monitor</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/remon1.png" alt="task6"></p><h2 id="task7-1"><a href="#task7-1" class="headerlink" title="task7"></a>task7</h2><p>这个题目比较ez</p><p><img src="/images/Windows%20Fundamentals%202%E6%95%99%E7%A8%8B/task7.png" alt="task7"></p><p>ipconfig 要展示所有细节的话 在后面加&#x2F; all</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><h2 id="task8-1"><a href="#task8-1" class="headerlink" title="task8"></a>task8</h2><p>这一题方法与task7 第一题题方法一致</p><h2 id="windows基本功能3"><a href="#windows基本功能3" class="headerlink" title="windows基本功能3"></a>windows基本功能3</h2><p>总算来到了最后一个了 速战速决</p><h3 id="task2-2"><a href="#task2-2" class="headerlink" title="task2"></a>task2</h3><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/task1.png" alt="task1"></p><p>第一个他问定期更新的时间是多少？我们打开设置点击更新<br><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/1.png" alt="1"></p><p>点开更新历史 就能发现日期<br><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/2.png" alt="2"></p><h3 id="task3-2"><a href="#task3-2" class="headerlink" title="task3"></a>task3</h3><p>很幸运 任务二也只有一道题<br><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/task2.png" alt="task2"></p><p>打开设置找到Windows security这个选项 你就可以发现答案</p><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/proten.png" alt="task22"></p><h3 id="task4-2"><a href="#task4-2" class="headerlink" title="task4"></a>task4</h3><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/task4.png" alt="task4"></p><p>一开始看这道题看得一头雾水的 不知道说啥 先不管他 我们上面已经打开了virus&amp;threat protection</p><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/dakai.png" alt="4"></p><p>接着点开manage setting 就会发现就是实时保护(real-time protection)<br>本人因为我的世界就被这个老六sha掉了 害我的存档之间没了</p><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/dakai2.png" alt="4"></p><h3 id="task5-2"><a href="#task5-2" class="headerlink" title="task5"></a>task5</h3><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/task5.png" alt="task5"></p><p>机场wifi毫无疑问就是公共网络 public network</p><h3 id="task6-2"><a href="#task6-2" class="headerlink" title="task6"></a>task6</h3><p>就是给你读的 </p><p>讲了Microsoft Defender SmartScreen的作用</p><h3 id="task7-2"><a href="#task7-2" class="headerlink" title="task7"></a>task7</h3><p>tpm就是Trusted Platform Module</p><h3 id="task8-2"><a href="#task8-2" class="headerlink" title="task8"></a>task8</h3><p>BitLocker 与受信任平台模块 (TPM) 一起使用时可提供最大程度的保护</p><p>BitLocker 驱动器加密是一种与操作系统集成的数据保护功能，可解决因计算机丢失、被盗或不当退役而导致的数据盗窃或泄露威胁</p><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/task8.png" alt="task8"></p><p>我们查看微软官方文档可以知道 没有tpm的需要准备a startup key</p><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/8.png" alt="8"></p><h3 id="task-9"><a href="#task-9" class="headerlink" title="task 9"></a>task 9</h3><p>卷影复制服务 (VSS) 协调所需的操作来创建要备份的数据的一致卷影副本（也称为快照或时间点副本）。 </p><p>卷影副本存储在每个启用了保护的驱动器上的系统卷信息文件夹中。</p><p>如果启用了 VSS(打开了系统保护)，您可以在高级系统设置中执行以下任务。 </p><ul><li>创建还原点</li><li>执行系统还原</li><li>配置恢复设置</li><li>删除还原点</li></ul><p><img src="/images/Windows%20Fundamentals%203%E6%95%99%E7%A8%8B/9.png" alt="9"></p><p>终于我们把所有的Windows function搞完了 基础篇 不难 主要是给我们熟悉一下操作和常用的程序 Windows安全工具 可以用来检查安全事件</p>]]></content>
      
      
      
        <tags>
            
            <tag> windows 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Incident Surface教程</title>
      <link href="/2025/01/17/Linux-Incident-Surface%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/17/Linux-Incident-Surface%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ok啊 因为下学期要来一个linux的课 我打算先把tryhackme的linux先搞一遍 学习学习linux的命令 方便下学期学习</p><p>本次教程用了ps lsof journalctl dpkg命令 查了auth.log和dpkg.log 这些log中都得学会用grep命令 这个是真的好用</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20110940.png" alt="开头"></p><p>我们用ssh先连接一下机子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh tryhackme@ip</span><br></pre></td></tr></table></figure><p>task3是一个看的文章 我们直接跳过</p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/task4.png" alt="task4"></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>我们按照文章所说 先运行一个简单程序<br>但首先记得先sudo su </p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20160531.png" alt="第一步"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc simple.c -o /tmp/simple</span><br><span class="line">/tmp/simple</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20160920.png" alt="第1步"></p><p>这里的gcc是c的编译器</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>我们使用ps aux查看运行的进程<br>-aux 显示所有包含其他使用者的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep simple</span><br><span class="line">搜索进程是simple这个名的</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20161218.png" alt="第二步"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>这一步要用到我们刚才查询到的进程的pid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -p pid</span><br><span class="line">用来搜索对应pid的进程</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20161542.png" alt="第三步"></p><p>lsof下面显示的东西等让我们对文件了解多一点</p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>我们先回到&#x2F;home&#x2F;activities&#x2F;processes 启动一下netcom(.&#x2F;netcom) 这一步能让我们连接到远程ip的</p><p>其实到这一步 我们已找到了第一题的答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -l -P-n</span><br><span class="line">查找我们刚才的netcom进程</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20162402.png" alt="第四步"></p><p>进入osquery </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osqueryi</span><br><span class="line">SELECT pid, fd, socket, local_address, remote_address,remote_port  FROM process_open_sockets WHERE pid =你的pid;</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20163204.png" alt="第四步"></p><p>一下子把端口和ip都搞到手了</p><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>开始之前 先运行这三个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd attacker -G sudo</span><br><span class="line">sudo passwd attacker</span><br><span class="line">echo &quot;attacker ALL=(ALL:ALL) ALL&quot; | sudo tee -a /etc/sudoers</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20165656.png" alt="第五步"></p><p>假如我们cat一下auth.log的useradd字眼</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20165656.png" alt="cat"></p><p>到etc的passwd里面查找<br><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-17%20171452.png" alt="passwd"></p><p>你就能发现刚才操作的痕迹</p><h3 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h3><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/task5.png" alt="task"></p><p>先创建一个配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/suspicious.service</span><br></pre></td></tr></table></figure><p>将以下复制粘贴进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Suspicious_Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/activities/processes/suspicious</span><br><span class="line">Restart=on-failure</span><br><span class="line">User=nobody</span><br><span class="line">Group=nogroup</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重启一下服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重新加载 systemd 管理器配置以识别新服务：</span><br><span class="line">命令：sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">启用服务在启动时运行：</span><br><span class="line">命令：sudo systemctl enable suspicious.service</span><br><span class="line"></span><br><span class="line">立即开始服务。</span><br><span class="line">命令：sudo systemctl start suspicious.service</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/3%E4%B8%AAsys.png" alt="第五"></p><p>我们能看到运行成功</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/running.png" alt="第五"></p><p>运行成功之后到&#x2F;etc&#x2F;systemd&#x2F;system 中查找<br>你会发现一个叫benign.service的东西 cat一下就会发现他和我们写的那个脚本差不多</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/bengin.png" alt="ben"></p><p>其中的execstart的benign就是题目需要的进程</p><p>最后一题的话 就是搜索日记 一个一个数 直接输入journalctl可能要找一下九月11的记录 我们可以根据日志进行筛选 能看出有七个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u benign.service --since &quot;2024-09-11&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/journalctl.png" alt="jour"></p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/task6.png" alt="task6"></p><p>创建一个目录 然后创建control文件和恶意脚本</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/control.png" alt="control"></p><p>把这一行复制到control里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Package: malicious-package</span><br><span class="line">Version: 1.0</span><br><span class="line">Section: base</span><br><span class="line">Priority: optional</span><br><span class="line">Architecture: all</span><br><span class="line">Maintainer: attacker@test.com</span><br><span class="line">Description: This is a malicious Package</span><br></pre></td></tr></table></figure><p>然后vim创建一个名字叫postinst的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Malicious post-installation script</span><br><span class="line"># It will run this script after installation</span><br><span class="line"></span><br><span class="line"># Print a suspicious message - for demonstration</span><br><span class="line">echo &quot;something suspicious&quot;</span><br></pre></td></tr></table></figure><p>给脚本赋权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 malicious-package/DEBIAN/postinst(记得你的路径要搞对)</span><br></pre></td></tr></table></figure><p>退回到malicious-package的根目录 构建安装包</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/goujian.png" alt="goujian"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i malicious-package.deb</span><br></pre></td></tr></table></figure><p>搞完这一一步<br>使用dpkg进行检查已经安装的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep malicious</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/jianchaanz.png" alt="jiancha"></p><p>接着我们查看dpgk.log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot; install &quot; /var/log/dpkg.log</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/chackanzhuang.png" alt="jiancha"></p><p>你会发现第二题的答案出来了 c2omm</p><h2 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h2><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/%E9%A2%98%E7%9B%AE7.png" alt="task7"></p><p>其实看到题目一直被困在auth中 我以为只有一个 进入到&#x2F;var&#x2F;log中 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll auth*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实会发现三个auth的日志</p><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/auth.png" alt="auth"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat auth.log | grep ssh</span><br><span class="line">cat auth.log.1 | grep ssh</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/auth.png" alt="auth"></p><p>题目说是ssh 我们就搜关键词 一个一个检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat auth.log | grep ssh</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/authlog2.png" alt="check"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat auth.log.1 | grep ssh</span><br></pre></td></tr></table></figure><p><img src="/images/Linux%20Incident%20Surface%E6%95%99%E7%A8%8B/authcheck.png" alt="check"></p><p>到此所有任务就算完成了 只能说是做的过程波澜曲折了 可能也是我比较菜吧 继续加油</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux 安全 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个入门的Investigating Windows教程</title>
      <link href="/2025/01/15/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%9A%84Investigating%20Windows%E6%95%99%E7%A8%8B/"/>
      <url>/2025/01/15/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E7%9A%84Investigating%20Windows%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近也是开始放寒假了，从网上知道了try hack me这个网址 刚好本人的技术又不咋地 于是决定好好提升一下技术 从最简单的基础部分开始。</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20201646.png" alt="主题"></p><p>这次使用了cmd powershell 注册表 计算机管理 任务计划程序 事件查看器 防火墙 c盘的system32的文件 <del>(省流）</del>都是蛮基础的windows工具</p><hr><p>我们来看看第一道题</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20201913.png" alt="第一题"><br>大致意思就是这个windows机器的版本和年份是什么</p><p>进入主机之后 直接点击设置 在其中查看操作系统的版本号为windows server 2016</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20145316.png" alt="第一题解释"></p><p>第二种办法就是在cmd中输入<strong>systeminfo</strong> 查看版本信息</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20202928.png" alt="第一题解释"></p><hr><p>下一题 题目大意谁是最晚登录的</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20203100.png" alt="第二题"></p><p>我们现在cmd里面输入net user 先查看有哪些用户</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20203406.png" alt="第二题解释1"></p><p>发现有五个用户 我们用net user 用户名 来一个一个排查 对比last logon的时间可以知道最后一个是administraor</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20203524.png" alt="第二题解释1"></p><p>当然 这是个土办法 我们还有一招 打开powershell 输入以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-localuser |select name,lastlogon</span><br></pre></td></tr></table></figure><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20090059.png" alt="第二题解释2"></p><p>很简单明了的可以看出谁是最后一个登录的用户<br><del>其实顺便下面一道题 把john的做最后登录时间查出来了</del></p><hr><p>下面一题</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20203706.png" alt="第三题"></p><p>这题我们使用net user john来查看时间 </p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20203826.png" alt="第三题解释"></p><hr><p>接着下一题</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20204914.png" alt="第四题"></p><p>看这个ip的话有一个很nt的方法 在你打开这个机的时候 前几分钟会弹出一个终端 那上面写着ip</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-14%20150219.png" alt="第四题解释1"></p><p>正经办法还有一个 就是在注册表里面查找那个程序 <strong>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</strong> 你就会发现这个程序的ip</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20090843.png" alt="第四题解释2"></p><hr><p>接下来是哪几个用户是属于administraor组</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20091809.png" alt="第五题"></p><p>直接在计算机管理里面查看administraor组里面有谁就可以了</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20091600.png" alt="第五题解释"></p><hr><p>下面几个题 可以一起解决了</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20092017.png" alt="第六题"></p><p>其实我们可以大致猜出他是个恶意程序 可以到任务计划程序中查找</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20092603.png" alt="第六题解释1"> </p><p>我们可以发现这个明显和别的任务有区别 我们点击action进行查看详细的信息</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20092427.png" alt="第六题解释2"> </p><p>可以知道运行的文件为nc.ps1 端口是1348</p><hr><p>下一题 jenny最后一次登录是啥时候</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20092902.png" alt="第七题"> </p><p>直接net user jenny 发现人家压根就没登陆过</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20093023.png" alt="第七题解释1"></p><hr><p>这些东西是怎么来的</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20093156.png" alt="第八题"></p><p>打开c盘文件夹 发现一个突兀的文件夹tmp 第六感告诉我这个文件夹绝壁有问题 直接打开 查看里面的文件的时间 19年3月2日 </p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20093508.png" alt="第八题解释"></p><hr><p>一次的特殊权限的新登录（原谅我的瞎寄吧翻译）</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20093542.png" alt="第九题"></p><p>这题的话蛮有意思的 我是在事件发生器里面的security筛选4672（问了度娘 这个就是题目需要的Special privileges assigned to new logon.）</p><p>结果死活找不到需要的。后来我去观摩了一下大佬的做法，上面一道题不是知道最早登录的时间嘛 19年3月2日 用筛选器选出这一天的4672的所有记录 再根据提示 秒是49，就在里面找到了一个记录。</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20094502.png" alt="第九题"></p><p>啥工具搞密码</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20094900.png" alt="第十题"></p><p>这题挺好的 mimikatz直接秒了（点开这个机子 时不时就有个mimikatz弹窗） 还有一招 点开tmp文件的min-out文件 里面可以看到</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20094950.png" alt="第十题"></p><p>最后一波问题</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20095638.png" alt="最后一波"></p><p>打开c盘的C:\Windows\System32\drivers\etc的host文件 </p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20095508.png" alt="最后一波"></p><p>这两个谷歌的ip感觉不太对劲哦 最后一题就可以直接输入google.com 第一题ip就是76.32.97.132</p><hr><p>第二题 题目刚好涉及到了网站服务器 windows就是iis服务 我们去c盘找一下有啥线索吗</p><p>inetpub文件夹是iis服务端的一个核心部分 网站目录啥的都存储在那 我们可以进去找找有什么线索吗</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20101030.png" alt="最后一波"></p><hr><p>第三题端口 可以在防火墙里面查看 发现是1337</p><p><img src="/images/%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-01-15%20100137.png" alt="最后一波"></p><p>就这样 完成了第一个room。其实这个还算是基础的room 来给我们熟悉一下 我们遇到问题要去哪个区域查找我们想要的数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/29/hello-world/"/>
      <url>/2024/12/29/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index-1.html"/>
      <url>/about/index-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Gallery</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>books</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>network 网络概念</title>
      <link href="/about/network-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5.html"/>
      <url>/about/network-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络知识的介绍"><a href="#网络知识的介绍" class="headerlink" title="网络知识的介绍"></a>网络知识的介绍</h1><h2 id="osi七层模型"><a href="#osi七层模型" class="headerlink" title="osi七层模型"></a>osi七层模型</h2><p>OSI 模型是一个描述网络功能的概念框架。简单来说，OSI 模型标对计算机系统彼此之间发送信息的方式进行了标准化。</p><p>分为：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><strong>物理层</strong>（Physical Layer）是计算机网络OSI模型中<strong>最低</strong>的一层，也是<strong>最基本</strong>的一层。简单的说，网络的物理层面确保<strong>原始的数据</strong>可在各种<strong>物理媒体</strong>上<strong>传输</strong>。</p><p>物理层规定：为传输数据，需要<strong>物理链路</strong>与<strong>设备</strong>的建立、维持、拆除，并具有<strong>机械的</strong>、<strong>电子的</strong>、<strong>功能的</strong>、<strong>规范</strong>的特性。</p><p>第一层的数据单元是<strong>比特</strong>（bit）。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><p>为数据段设备提供传输数据的通路</p></li><li><p>传输数据</p></li></ol><h4 id="常见物理层设备"><a href="#常见物理层设备" class="headerlink" title="常见物理层设备"></a>常见物理层设备</h4><ul><li>光纤</li><li>CAT-5线</li><li>CAT-6线</li><li>CAT-7线</li><li>RJ-45接头</li><li>集线器</li><li>串口</li><li>并口</li></ul><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ul><li>曼彻斯特编码 </li><li>差分曼彻斯特编码</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层（Data Link Layer）是OSI参考模型<strong>第二层</strong>，位于物理层与网络层之间。可以细分成<strong>介质访问控制（MAC）子层</strong>和<strong>逻辑链路控制（LLC）子层</strong>。</p><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>数据链路层用于跨物理层在<strong>网段节点</strong>之间传输数据，通常指以太网、无线局域网等通信手段。数据链路层提供了在网络的两个实体之间传输数据的功能，并且提供了<strong>差错检测</strong>用于<strong>纠正</strong>物理层中发生的错误。</p><p>只提供导线的一端到另一端（本质是点到点）的<strong>数据传输</strong>。</p><p>数据链路层的以太网协议规定了一组二进制电信号为<strong>数据帧</strong>，数据帧的报头 head 就包含<strong>目标 MAC 地址</strong>和<strong>源 MAC 地址</strong></p><p>第二层的数据单元是 <strong>帧</strong>（frame）。</p><p>帧都包括一个帧头 主题和一个帧尾</p><ul><li>帧头：源节点和目的节点的mac地址</li><li>主体：要传输的比特</li><li>帧尾：包括错误检测信息</li></ul><h4 id="常见数据链路层的设备"><a href="#常见数据链路层的设备" class="headerlink" title="常见数据链路层的设备"></a>常见数据链路层的设备</h4><ul><li>网卡（物理层和数据链路层的MAC子层）</li><li>交换机 是数据链路层设备。</li><li>桥接器（又称网桥）</li></ul><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>异步传输模式</p><ul><li><p>VLAN（IEEE 802.1Q）</p></li><li><p>以太网（IEEE 802.3）</p></li><li><p>Wi-Fi（IEEE 802.11）</p></li><li><p>PPP协议<br>点对点协议 一种数据链路层封装协议 有PAP和CHAP两种方式</p></li><li><p>PPPoE协议<br>，以太网上的点对点协议，是将点对点协议（PPP）封装在以太网（Ethernet）框架中的一种网络隧道协议。</p></li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层是<strong>互联网通信过程</strong>的一部分，这是连接发生的地方，在不同网络之间来回<strong>发送数据包</strong>来进行通信，处理不同网络之间的数据路由和发送。</p><p>用于将接收到的数据段从一台计算机传输到位于不同网络中的另一台计算机。</p><p>第三层的数据单元为<strong>数据包</strong></p><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ol><li>寻址<br>对网络层而言使用IP地址来<strong>唯一标识</strong>互联网上的各个寻址，网络层依靠IP地址进行<strong>相互通信</strong>（类似于MAC地址），详细的编址方案参见IPv4和IPv6。<br></li><li>路由<br>在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</li></ol><h4 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h4><ul><li>IP （V4、V6）</li><li>ICMP（V4、V6）</li><li>IPsec</li><li>RIP</li><li>OSPF</li></ul><h4 id="具有网络层功能的设备"><a href="#具有网络层功能的设备" class="headerlink" title="具有网络层功能的设备"></a>具有网络层功能的设备</h4><ul><li>路由</li><li>三层交换机</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层通过分段、流量控制和差错控制来控制通信的可靠性。支持不同主机上运行的应用程序之间的端到端通信。</p><p>第四次的数据单元可以说<strong>报文段</strong>或<strong>数据段</strong>(<strong>tcp</strong>)和<strong>数据报</strong>(<strong>udp</strong>)</p><h4 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h4><ul><li>tcp</li><li>udp</li></ul><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>主要利用传输层提供的端到端数据传输服务，为两个会话层实体进行<strong>会话</strong>（Session），而进行的对话连接的管理服务。</p><h4 id="会话层服务"><a href="#会话层服务" class="headerlink" title="会话层服务"></a>会话层服务</h4><ul><li>认证</li><li>权限</li><li>会话恢复</li></ul><h4 id="会话层协议"><a href="#会话层协议" class="headerlink" title="会话层协议"></a>会话层协议</h4><ul><li>PAP, 密码认证协议</li><li>PPTP, 点对点隧道协议</li><li>L2TP, 第二层隧道协议</li><li>RPC, 远程过程调用</li><li>SDP, 套接字直接协议</li></ul><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>表示层向上对应用层服务，向下接受来自会话层的服务。表示层为在应用过程之间传送的信息提供表示方法的服务，它只关心信息发出的语法和语义</p><p>表示层从应用层接收数据。这些数据是以字符和数字的形式出现的，表示层将这些字符和数字转换成机器可理解的二进制格式。</p><p>为不同终端的上层用户提供数据和信息正确的语法表示变换方法。表示层确保数据以应用层可以理解的形式传递。处理数据编码、压缩和加密。</p><h4 id="表示层的主要功能"><a href="#表示层的主要功能" class="headerlink" title="表示层的主要功能"></a>表示层的主要功能</h4><ul><li>数据语法转换</li><li>语法表示</li><li>连接管理</li><li>数据处理</li><li>数据加密和解密</li><li>数据压缩和解压</li><li>数据编码和解码</li></ul><h4 id="表示层协议"><a href="#表示层协议" class="headerlink" title="表示层协议"></a>表示层协议</h4><ul><li>HTTP&#x2F;HTTPS</li><li>FTP&#x2F;FTPS</li><li>SSH</li><li>Telnet</li><li>ASN.1</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>用层直接和应用程序接口结合，并提供常见的网络应用服务。应用层也向第六层表示层发出请求。</p><p>应用层直接向最终用户应用程序提供网络服务。</p><h4 id="协议-2"><a href="#协议-2" class="headerlink" title="协议"></a>协议</h4><ul><li>DHCP</li><li>DNS</li><li>FTP</li><li>POP3</li></ul><p>简单来说 假如你在给你的异地女朋友发微信信息 微信这个app就是属于<strong>应用层</strong> 将你发的这个信息转化为机器<strong>能够懂的适合传输</strong>的形式 这个就是<strong>表示层</strong>的作用 这个信息要发给你的女朋友 你和女朋友的微信会创建一个<strong>会话连接</strong> 会话层会在信息发过去的时候<strong>保证传输</strong>顺利进行 传输层会把数据<strong>分成</strong>适合传输的<strong>数据包</strong>进行传输 网络层会规划一条<strong>合适的路径</strong>传输信息 数据链路层会通过物理网络将<strong>数据包传给</strong>物理层 物理层就能把数据包发送到接收方手机 就能接收到发送方的信息</p><h2 id="tcp-ip模型"><a href="#tcp-ip模型" class="headerlink" title="tcp&#x2F;ip模型"></a>tcp&#x2F;ip模型</h2><ul><li>应用层</li><li>传输层</li><li>网络接口层</li><li>链路层</li></ul><h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>由网络号和主机号组成</p><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>0.0.0.0用来寻找自己的ip</p><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><ul><li>A类 10.0.0.0 - 10.255.255.255 (10&#x2F;8)</li><li>B类 172.16.0.0 - 172.31.255.255 (172.16&#x2F;12)</li><li>C类 192.168.0.0 - 192.168.255.255 (192.168&#x2F;16)</li></ul><h2 id="dhcp协议"><a href="#dhcp协议" class="headerlink" title="dhcp协议"></a>dhcp协议</h2><p>动态主机配置协议 用于集中对用户IP地址进行动态管理和配置。</p><h3 id="DHCP遵循四个步骤：发现、提供、请求和确认-DORA-："><a href="#DHCP遵循四个步骤：发现、提供、请求和确认-DORA-：" class="headerlink" title="DHCP遵循四个步骤：发现、提供、请求和确认 (DORA)："></a>DHCP遵循四个步骤：发现、提供、请求和确认 (DORA)：</h3><ul><li>DHCP发现：客户端将广播 DHCPDISCOVER 消息，寻找本地DHCP服务器（如果存在）。</li><li>DHCP提供：服务器以 DHCPOFFER 消息进行响应，其中包含可供客户端接受的 IP 地址。</li><li>DHCP请求：客户端以 DHCPREQUEST 消息进行响应，表明它已接受提供的 IP。</li><li>DHCP确认：服务器以 DHCPACK 消息进行响应，以确认提供的 IP 地址现已分配给该客户端。</li></ul><h2 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h2><p>arp协议(地址解析协议) IP地址对mac地址的映射 询问IP地址对应的mac地址</p><p>目标 MAC 地址<br>源 MAC 地址</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index-1.html"/>
      <url>/categories/index-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/music.css"/>
      <url>/css/music.css</url>
      
        <content type="html"><![CDATA[.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>search</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index-1.html"/>
      <url>/tags/index-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/touming.css"/>
      <url>/css/touming.css</url>
      
        <content type="html"><![CDATA[/* 文章页背景 */.layout_post>#post {  /* 透明度为 0.7 */  background: rgba(255, 255, 255, 0.7);}/* 所有页面背景 */#aside_content .card-widget, #recent-posts>.recent-post-item, .layout_page>div:first-child:not(.recent-posts), .layout_post>#page, .layout_post>#post, .read-mode .layout_post>#post {  /* 透明度为 0.7 */  background: rgba(255, 255, 255, 0.7);}/* 侧边卡片的透明度 */:root {  --card-bg: rgba(255, 255, 255, 0.7);}/* 页脚透明 */#footer {  /* 透明度为 0.7 */  background: rgba(255, 255, 255, 0.7);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index-2.html"/>
      <url>/tags/index-2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
  
</search>
