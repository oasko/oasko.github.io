## task2
dad
- **披露**与保密相反。换句话说，披露机密数据将是对保密性的侵犯。
- **更改**与完整性相反。例如，支票的完整性是不可或缺的。
- **破坏/拒绝**与可用性相反。
考虑前面病人记录和相关系统的例子：

- 泄露：与大多数现代国家一样，医疗保健提供者必须保持医疗记录的机密性。因此，如果攻击者成功窃取其中一些医疗记录并将其转储到网上供公众查看，医疗保健提供者将因这种数据泄露攻击而蒙受损失。
- 篡改：如果攻击者设法修改患者的医疗记录，情况将非常严重。这种篡改攻击可能会导致错误的治疗，因此，这种篡改攻击可能会危及生命。
- 破坏/拒绝：假设一家医疗机构完全无纸化。如果攻击者设法使数据库系统不可用，该机构将无法正常运行。他们可以暂时恢复纸质文件；但是，患者记录将不可用。这种拒绝攻击将使整个机构陷入停顿。
CIA三要素的对立面是DAD三要素：披露、改变、毁灭。
# task3
使用安全模型。在此任务中，将介绍三个基础安全模型：

- Bell-LaPadula 模型
- Biba 诚信模型
- 克拉克-威尔逊模型

#### Bell-LaPadula 模型

Bell-LaPadula 模型旨在通过指定三条规则来实现**保密性：**

- **简单安全属性**：此属性称为“不可读取”；它规定处于较低安全级别的主体无法读取处于较高安全级别的对象。此规则可防止访问授权级别以上的敏感信息。
- **星型安全属性**：此属性称为“不可写入”；它规定较高安全级别的主体无法写入较低安全级别的对象。此规则可防止向较低安全级别的主体泄露敏感信息。
- **自主安全属性**：此属性使用访问矩阵来允许读写操作。下表显示了一个示例访问矩阵，该矩阵与前两个属性结合使用。

|主题|对象A|对象 B|
|---|---|---|
|主题 1|写|禁止访问|
|主题 2|读/写|读|

前两个属性可以概括为“写下来，读下来”。您可以与具有较高安全级别权限的人员共享机密信息（写下来），也可以从具有较低安全级别权限的人员那里获取机密信息（读下来）。

Bell-LaPadula 模型也存在一些局限性。例如，它不是为处理文件共享而设计的。

### Biba 模型

Biba 模型旨在通过指定两个主要规则来实现**诚信：**

- **简单完整性属性**：此属性称为“不读取”；完整性较高的主体不应从完整性较低的对象读取。
- **星型完整性属性**：此属性称为“禁止写入”；完整性较低的主体不应写入完整性较高的对象。

这两个属性可以概括为“读出来，写下来”。这条规则与贝尔-拉帕杜拉模型形成对比，这并不奇怪，因为一个关注机密性，而另一个关注完整性。

Biba 模型存在各种局限性。其中一个例子就是它不能处理内部威胁（内部威胁）。

### 克拉克-威尔逊模型

克拉克-威尔逊模型还旨在通过使用以下概念来实现诚信：

- **受限数据项 (CDI)**：这指的是我们想要保留其完整性的数据类型。
- **不受约束的数据项（UDI）**：指超出CDI的所有数据类型，例如用户和系统输入。
- **转换程序 (TP)**：这些程序是程序化操作，例如读取和写入，并且应该保持 CDI 的完整性。
- **完整性验证程序 (IVP)**：这些程序检查并确保 CDI 的有效性。
## task4
**纵深防御**是指建立多层次的安全体系，因此也称为多级安全。

## task5
### ISO/IEC 19249
ISO/IEC 19249 列出了五项_架构_原则：

1. **域分离**：每组相关组件都被分组为单个实体；组件可以是应用程序、数据或其他资源。每个实体都有自己的域，并被分配一组通用的安全属性。例如，考虑 x86 处理器特权级别：操作系统内核可以在环 0（最高特权级别）中运行。相反，用户模式应用程序可以在环 3（最低特权级别）中运行。域分离包含在 Goguen-Meseguer 模型中。

2. **分层**：当系统被构建为许多抽象级别或层次时，就可以在不同级别实施安全策略；此外，验证操作也是可行的。让我们考虑 OSI（开放系统互连）模型及其七层网络。OSI 模型中的每一层都为其上一层提供特定的服务。这种分层使得实施安全策略和轻松验证系统是否按预期运行成为可能。编程世界中的另一个例子是磁盘操作；程序员通常使用所选高级编程语言提供的磁盘读写功能。编程语言隐藏低级系统调用并将其呈现为更用户友好的方法。分层与纵深防御有关。

3. **封装**：在面向对象编程 (OOP) 中，我们隐藏低级实现，并通过提供特定方法来防止直接操作对象中的数据。例如，如果您有一个时钟对象，则应提供一种方法，`increment()`而不是让用户直接访问变量`seconds`。这样做的目的是防止变量的值无效。同样，在较大的系统中，您将使用（甚至设计）适当的应用程序编程接口 ( API )，供应用程序访问数据库。

4. **冗余**：此原则确保可用性和完整性。冗余相关的示例有很多。考虑具有两个内置电源的硬件服务器的情况：如果一个电源发生故障，系统仍可继续运行。考虑具有三个驱动器的 RAID 5 配置：如果一个驱动器发生故障，则可以使用其余两个驱动器获取数据。此外，如果其中一个磁盘上的数据被错误更改，则可以通过奇偶校验检测到，从而确保数据的完整性。

5. **虚拟化**：随着云服务的出现，虚拟化变得越来越普遍和流行。虚拟化的概念是在多个操作系统之间共享一组硬件。虚拟化提供了沙盒功能，可以改善安全边界、安全引爆和对恶意程序的观察。

ISO/IEC 19249 教授五项_设计_原则：

1. **最小权限**：在回答“谁可以访问什么？”这个问题时，您也可以非正式地将其表述为“需要基础”或“需要知道基础”。最小权限原则教导您应为某人提供执行其任务所需的最少权限，仅此而已。例如，如果用户需要能够查看文档，则应授予他们读取权限，但不授予其写入权限。

2. **攻击面最小化**：每个系统都有漏洞，攻击者可能会利用这些漏洞来破坏系统。一些漏洞是已知的，而另一些漏洞尚未被发现。这些漏洞代表着我们应该尽量减少的风险。例如，在强化Linux系统的步骤之一中，我们会禁用任何不需要的服务。

3. **集中式参数验证**：许多威胁都源于系统接收输入，尤其是来自用户的输入。无效输入可用于利用系统中的漏洞，例如拒绝服务和远程代码执行。因此，参数验证是确保系统状态正确的必要步骤。考虑到系统处理的参数数量，参数验证应集中在一个库或系统中。

4. **集中式通用安全服务**：作为一项安全原则，我们应致力于集中化所有安全服务。例如，我们将创建一个集中式服务器进行身份验证。当然，您可以采取适当的措施来确保可用性并防止产生单点故障。

5. **准备错误和异常处理**：每当我们构建系统时，我们都应该考虑到错误和异常确实会发生。例如，在购物应用程序中，客户可能会尝试订购缺货商品。数据库可能会超载并停止响应 Web 应用程序。该原则教导我们，系统应设计为故障安全；例如，如果防火墙崩溃，它应该阻止所有流量而不是允许所有流量。此外，我们应该注意错误消息不会泄露我们认为机密的信息，例如转储包含与其他客户相关的信息的内存内容。

## task6
感兴趣的两个安全原则是：

- 信任但核实
- 零信任

**信任但要核实**：该原则告诉我们，即使我们信任某个实体及其行为，也应始终进行核实。实体可能是用户或系统。核实通常需要设置适当的日志记录机制；核实表示查看日志以确保一切正常。实际上，核实所有内容是不可行的；只要想想审查单个实体采取的所有行动（例如单个用户浏览的互联网页面）所需的工作量即可。这需要自动化安全机制，例如代理、入侵检测和入侵防御系统。

**零信任**：该原则将信任视为一种漏洞，因此它迎合了内部威胁。在将信任视为一种漏洞之后，零信任试图消除它。它间接地教导人们“永远不要信任，永远要验证”。换句话说，每个实体都被视为敌对实体，直到证明不是为止。零信任不会根据设备的位置或所有权授予其信任。这种方法与信任内部网络或企业拥有的设备的旧模式形成鲜明对比。在访问任何资源之前，都需要进行身份验证和授权。因此，如果发生任何违规行为，如果实施了零信任架构，损害将更加可控。

